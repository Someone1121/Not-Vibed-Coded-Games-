<!DOCTYPE html>
<html>
<head>
  <title>Volleyball Game 3.0</title>
  <style>
    body {
      margin: 0;
      background: radial-gradient(circle at 20% 20%, #8fd4ff 0%, #5aa7f5 35%, #245f9a 100%);
      font-family: 'Segoe UI', Arial, sans-serif;
    }
    #game-container {
      position: relative;
      width: min(1200px, 96vw);
      margin: 16px auto 28px auto;
    }
    canvas {
      display: block;
      width: 100%;
      aspect-ratio: 9 / 5;
      height: auto;
      background: #0a1b2a;
      border-radius: 14px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.35), 0 0 0 1px rgba(255,255,255,0.05);
    }
    #gui-buttons {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 100;
    }
    .gui-btn {
      padding: 8px 16px;
      font-size: 12px;
      font-weight: bold;
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      min-width: 100px;
    }
    .gui-btn:hover {
      transform: scale(1.05);
      border-color: rgba(255,255,255,0.8);
    }
    .gui-btn:active {
      transform: scale(0.95);
    }
    #btn-shop { background: linear-gradient(135deg, #4CAF50, #2E7D32); color: white; }
    #btn-casino { background: linear-gradient(135deg, #9C27B0, #6A1B9A); color: white; }
    #btn-chemistry { background: linear-gradient(135deg, #00BCD4, #0097A7); color: white; }
    #btn-caterpillar { background: linear-gradient(135deg, #8BC34A, #558B2F); color: white; }
    #btn-arena { background: linear-gradient(135deg, #F44336, #C62828); color: white; }
    #btn-simulation { background: linear-gradient(135deg, #FF9800, #E65100); color: white; }
    #btn-feed { background: linear-gradient(135deg, #CDDC39, #9E9D24); color: #333; display: none; }
    
    #coins-display {
      position: absolute;
      top: 10px;
      left: 10px;
      background: linear-gradient(135deg, #FFD700, #FFA000);
      padding: 8px 16px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 14px;
      color: #333;
      border: 2px solid rgba(255,255,255,0.5);
      z-index: 100;
    }
    
    #bottom-controls {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 100;
    }
    .control-btn {
      padding: 10px 20px;
      font-size: 14px;
      font-weight: bold;
      background: linear-gradient(135deg, #333, #555);
      color: white;
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .control-btn:hover {
      background: linear-gradient(135deg, #444, #666);
      border-color: rgba(255,255,255,0.6);
    }
    #btn-3d { background: linear-gradient(135deg, #2196F3, #1565C0); color: white; }
    #btn-3d.active { background: linear-gradient(135deg, #4CAF50, #2E7D32); }
  </style>
</head>
<body>

<div id="game-container">
  <canvas id="game" width="900" height="500"></canvas>
  
  <div id="coins-display">üí∞ Coins: <span id="coin-count">100</span></div>
  
  <div id="gui-buttons">
    <button class="gui-btn" id="btn-3d" onclick="toggle3DBtn()">üéÆ 3D Mode</button>
    <button class="gui-btn" id="btn-shop" onclick="toggleShop()">üõí Shop</button>
    <button class="gui-btn" id="btn-casino" onclick="toggleCasino()">üé∞ Casino</button>
    <button class="gui-btn" id="btn-chemistry" onclick="toggleChemistry()">‚öóÔ∏è Chemistry</button>
    <button class="gui-btn" id="btn-caterpillar" onclick="toggleCaterpillar()">üêõ Caterpillar</button>
    <button class="gui-btn" id="btn-feed" onclick="feedCaterpillarBtn()">üçé Feed</button>
    <button class="gui-btn" id="btn-arena" onclick="switchToArena()">‚öîÔ∏è Arena</button>
    <button class="gui-btn" id="btn-simulation" onclick="switchToSim()">üåç World Sim</button>
  </div>
  
  <div id="bottom-controls">
    <button class="control-btn" onclick="restartGame()">üîÑ Restart</button>
    <button class="control-btn" onclick="togglePause()">‚è∏Ô∏è Pause</button>
  </div>
</div>

<script>
// ================== Core Setup ==================
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// ================== Configuration Constants ==================
const CONFIG = {
  // Physics
  GRAVITY: 0.35,
  GROUND_Y: 340,
  
  // Net dimensions
  NET_LEFT: 445,
  NET_RIGHT: 455,
  NET_TOP: 260,
  NET_BOTTOM: 430,
  
  // Player dimensions
  PLAYER_WIDTH: 40,
  PLAYER_HEIGHT: 90,
  
  // Player movement
  PLAYER_SPEED: 3.7,
  PLAYER_JUMP_POWER: 13.5,
  PLAYER_MAX_STAMINA: 100,
  
  // Bot tuning - base values for normal difficulty
  BOT_SPEED: 4.25,
  BOT_JUMP_POWER: 13.4,
  
  // Bot difficulty settings
  BOT_DIFFICULTY: {
    easy: {
      speed: 3.9,
      jumpPower: 13.0,
      homeX: 600,
      moveSpeedMultiplier: 0.85,
      accelMultiplier: 0.9,
      reactionMultiplier: 1.3,
      jumpCooldown: 10,
      spikeProximity: 180,
      wallBuffer: 50,
      swingForgiveness: 18
    },
    normal: {
      speed: 4.25,
      jumpPower: 13.4,
      homeX: 640,
      moveSpeedMultiplier: 1.0,
      accelMultiplier: 1.0,
      reactionMultiplier: 1.0,
      jumpCooldown: 8,
      spikeProximity: 200,
      wallBuffer: 2,
      swingForgiveness: 16
    },
    hard: {
      speed: 4.55,
      jumpPower: 13.9,
      homeX: 700,
      moveSpeedMultiplier: 1.15,
      accelMultiplier: 1.1,
      reactionMultiplier: 0.85,
      jumpCooldown: 5,
      spikeProximity: 230,
      wallBuffer: 70,
      swingForgiveness: 22
    }
  },
  
  // Player colors
  PLAYER_COLOR: "#1e88e5",
  CPU_COLOR: "#e53935",
  
  // Audio defaults
  AUDIO_DEFAULT_FREQ: 440,
  AUDIO_DEFAULT_DURATION: 0.12,
  AUDIO_DEFAULT_ATTACK: 0.005,
  AUDIO_DEFAULT_DECAY: 0.2,
  AUDIO_NOISE_DURATION: 0.08,
  AUDIO_NOISE_VOLUME: 0.18,
  
  // UI positioning
  STAMINA_BAR_MARGIN: 20,
  STAMINA_BAR_WIDTH: 220,
  STAMINA_BAR_HEIGHT: 16,
  STAMINA_BAR_Y: 20,
  
  // FX
  TRAIL_OPACITY_DECAY: 0.88,
  PARTICLE_OPACITY_DECAY: 0.96,
  PARTICLE_SIZE_DECAY: 0.93,
  
  // Timing
  STEP_MS: 1000 / 60  // Fixed-step timing at 60fps
};

// Convenience references for backward compatibility
const gravity = CONFIG.GRAVITY;
const groundY = CONFIG.GROUND_Y;
const netLeft = CONFIG.NET_LEFT;
const netRight = CONFIG.NET_RIGHT;
const netTop = CONFIG.NET_TOP;
const netBottom = CONFIG.NET_BOTTOM;

let keys = {};
let frameCount = 0;
let cameraShake = 0;
let paused = false;
let masterVolume = 1;
let botServeDelayFrames = 0;
const settings = {
  fxParticles: true,
  fxTrails: true,
  screenShake: true,
  trailStyle: "glow",
  soundStyle: "bright",
  soundLevel: 1,
  botDifficulty: "normal",
  targetScore: 10,
  mapIndex: 0
};

// ================== Extended Game State ==================
let gameMode = "volleyball"; // "volleyball", "arena", "simulation", "chemistry"
let showingShop = false;
let showingGambling = false;
let showingChemistry = false;

// Currency & Gambling System
const playerStats = {
  coins: 100,
  totalWins: 0,
  totalLosses: 0,
  currentBet: 0,
  slotSpinning: false,
  slotResults: [0, 0, 0],
  lastDiceRoll: 0
};

// Power-Up Shop System
const shopItems = [
  { id: "speedBoost", name: "Speed Boost", cost: 50, duration: 600, description: "+35% speed", active: false, timer: 0 },
  { id: "jumpBoost", name: "Jump Boost", cost: 40, duration: 600, description: "+25% jump", active: false, timer: 0 },
  { id: "staminaRegen", name: "Stamina Regen", cost: 30, duration: 900, description: "2x stamina regen", active: false, timer: 0 },
  { id: "giantBall", name: "Giant Ball", cost: 60, duration: 450, description: "Ball is 50% bigger", active: false, timer: 0 },
  { id: "slowCPU", name: "Slow CPU", cost: 75, duration: 600, description: "CPU 30% slower", active: false, timer: 0 },
  { id: "autoReceive", name: "Auto Receive", cost: 100, duration: 300, description: "Auto-catch nearby balls", active: false, timer: 0 }
];

// Arena Battle System (Smash Bros Style)
const arenaState = {
  active: false,
  playerHealth: 100,
  cpuHealth: 100,
  playerDamage: 0, // Knockback multiplier
  cpuDamage: 0,
  weapons: [],
  currentWeapon: null,
  cpuWeapon: null,
  attackCooldown: 0,
  cpuAttackCooldown: 0
};

const weaponTypes = [
  { id: "sword", name: "Sword", damage: 15, knockback: 8, range: 60, cooldown: 30, color: "#silver" },
  { id: "hammer", name: "Hammer", damage: 25, knockback: 15, range: 45, cooldown: 50, color: "#8B4513" },
  { id: "bow", name: "Bow", damage: 10, knockback: 5, range: 200, cooldown: 40, color: "#DEB887", projectile: true },
  { id: "bomb", name: "Bomb", damage: 30, knockback: 20, range: 80, cooldown: 90, color: "#333", explosive: true },
  { id: "staff", name: "Magic Staff", damage: 18, knockback: 12, range: 150, cooldown: 35, color: "#9932CC", projectile: true }
];

// Life Simulation System (WorldBox Style)
const simState = {
  active: false,
  entities: [],
  maxEntities: 50,
  selectedTool: "spawn",
  spawnType: "human",
  godPowers: {
    lightning: { cost: 10, cooldown: 0 },
    rain: { cost: 5, cooldown: 0 },
    earthquake: { cost: 20, cooldown: 0 },
    blessing: { cost: 15, cooldown: 0 },
    plague: { cost: 25, cooldown: 0 }
  },
  divineEnergy: 100,
  maxDivineEnergy: 100
};

const entityTypes = [
  { id: "human", name: "Human", color: "#FFD700", speed: 1.5, health: 50, hostile: false },
  { id: "warrior", name: "Warrior", color: "#DC143C", speed: 1.2, health: 80, hostile: true, damage: 10 },
  { id: "farmer", name: "Farmer", color: "#32CD32", speed: 1.0, health: 40, hostile: false, produces: "food" },
  { id: "mage", name: "Mage", color: "#9400D3", speed: 1.3, health: 35, hostile: false, magic: true },
  { id: "animal", name: "Animal", color: "#8B4513", speed: 2.0, health: 30, hostile: false },
  { id: "monster", name: "Monster", color: "#800000", speed: 1.8, health: 100, hostile: true, damage: 20 }
];

// Evil Caterpillar System
const caterpillar = {
  active: false,
  x: 100,
  y: groundY + 50,
  segments: 5,
  maxSegments: 20,
  hunger: 50,
  maxHunger: 100,
  foodEaten: 0,
  targetOpponent: false,
  attackDamage: 5,
  growthThreshold: 3, // Food needed to grow
  lastFedFrame: 0
};

// Chemistry System
const chemistryState = {
  active: false,
  elements: [],
  combinations: [],
  discovered: ["hydrogen", "oxygen", "carbon", "nitrogen"],
  currentMix: [],
  craftingResult: null
};

const baseElements = [
  { id: "hydrogen", symbol: "H", color: "#E8E8E8", description: "Lightest element" },
  { id: "oxygen", symbol: "O", color: "#FF6B6B", description: "Essential for life" },
  { id: "carbon", symbol: "C", color: "#333333", description: "Building block of life" },
  { id: "nitrogen", symbol: "N", color: "#87CEEB", description: "78% of air" },
  { id: "iron", symbol: "Fe", color: "#B8860B", description: "Strong metal" },
  { id: "uranium", symbol: "U", color: "#00FF00", description: "Radioactive" },
  { id: "gold", symbol: "Au", color: "#FFD700", description: "Precious metal" },
  { id: "silicon", symbol: "Si", color: "#A0A0A0", description: "Computer chips" }
];

const chemistryRecipes = [
  { inputs: ["hydrogen", "hydrogen", "oxygen"], output: "water", name: "Water", color: "#00BFFF" },
  { inputs: ["carbon", "oxygen", "oxygen"], output: "co2", name: "Carbon Dioxide", color: "#808080" },
  { inputs: ["nitrogen", "nitrogen", "nitrogen"], output: "ammonia", name: "Ammonia", color: "#FFFF00" },
  { inputs: ["uranium", "uranium", "uranium"], output: "nuke", name: "Nuclear Bomb", color: "#FF0000" },
  { inputs: ["hydrogen", "hydrogen", "hydrogen", "hydrogen"], output: "star", name: "Star", color: "#FFFF00" },
  { inputs: ["star", "star", "star"], output: "galaxy", name: "Galaxy", color: "#9932CC" },
  { inputs: ["galaxy", "galaxy", "galaxy"], output: "universe", name: "Universe", color: "#000080" },
  { inputs: ["water", "carbon", "nitrogen"], output: "life", name: "Life", color: "#00FF00" },
  { inputs: ["iron", "carbon"], output: "steel", name: "Steel", color: "#708090" },
  { inputs: ["silicon", "gold"], output: "computer", name: "Computer", color: "#00FFFF" }
];

// ================== Game Mode Functions ==================
function switchGameMode(mode) {
  gameMode = mode;
  showingShop = false;
  showingGambling = false;
  showingChemistry = false;
  
  // Reset specific mode states
  if (mode === "arena") {
    arenaState.active = true;
    arenaState.playerHealth = 100;
    arenaState.cpuHealth = 100;
    arenaState.playerDamage = 0;
    arenaState.cpuDamage = 0;
    spawnArenaWeapon();
  } else {
    arenaState.active = false;
  }
  
  if (mode === "simulation") {
    simState.active = true;
    simState.entities = [];
  } else {
    simState.active = false;
  }
  
  if (mode === "chemistry") {
    chemistryState.active = true;
    chemistryState.currentMix = [];
    chemistryState.craftingResult = null;
  } else {
    chemistryState.active = false;
  }
}

// ================== Gambling System Functions ==================
function placeBet(amount) {
  if (playerStats.coins >= amount) {
    playerStats.currentBet = amount;
    playerStats.coins -= amount;
    return true;
  }
  return false;
}

function spinSlots() {
  if (playerStats.slotSpinning) return;
  if (!placeBet(10)) return;
  
  playerStats.slotSpinning = true;
  const symbols = ["üçí", "üçã", "üçä", "üíé", "7Ô∏è‚É£", "‚≠ê"];
  
  setTimeout(() => {
    playerStats.slotResults = [
      Math.floor(Math.random() * symbols.length),
      Math.floor(Math.random() * symbols.length),
      Math.floor(Math.random() * symbols.length)
    ];
    
    // Calculate winnings
    const [a, b, c] = playerStats.slotResults;
    let winnings = 0;
    if (a === b && b === c) {
      winnings = a === 4 ? 100 : (a === 3 ? 50 : 25); // 777 = 100, diamonds = 50, others = 25
    } else if (a === b || b === c || a === c) {
      winnings = 5;
    }
    
    playerStats.coins += winnings;
    playerStats.slotSpinning = false;
    playerStats.currentBet = 0;
  }, 1500);
}

function rollDice() {
  if (!placeBet(5)) return 0;
  const roll = Math.floor(Math.random() * 6) + 1 + Math.floor(Math.random() * 6) + 1;
  playerStats.lastDiceRoll = roll;
  
  if (roll === 7 || roll === 11) {
    playerStats.coins += 15;
  } else if (roll === 2 || roll === 12) {
    playerStats.coins += 25;
  }
  return roll;
}

function betOnMatch(amount) {
  return placeBet(amount);
}

function collectMatchWinnings(won) {
  if (won) {
    playerStats.coins += playerStats.currentBet * 2;
    playerStats.totalWins++;
  } else {
    playerStats.totalLosses++;
  }
  playerStats.currentBet = 0;
}

// ================== Power-Up Shop Functions ==================
function buyPowerUp(itemId) {
  const item = shopItems.find(i => i.id === itemId);
  if (!item || playerStats.coins < item.cost || item.active) return false;
  
  playerStats.coins -= item.cost;
  item.active = true;
  item.timer = item.duration;
  applyPowerUp(item);
  return true;
}

function applyPowerUp(item) {
  switch(item.id) {
    case "speedBoost":
      p1.speed = CONFIG.PLAYER_SPEED * 1.35;
      break;
    case "jumpBoost":
      p1.jumpPower = CONFIG.PLAYER_JUMP_POWER * 1.25;
      break;
    case "slowCPU":
      p2.speed = CONFIG.BOT_SPEED * 0.7;
      break;
  }
}

function removePowerUp(item) {
  item.active = false;
  switch(item.id) {
    case "speedBoost":
      p1.speed = CONFIG.PLAYER_SPEED;
      break;
    case "jumpBoost":
      p1.jumpPower = CONFIG.PLAYER_JUMP_POWER;
      break;
    case "slowCPU":
      p2.speed = CONFIG.BOT_SPEED;
      break;
  }
}

function updatePowerUps() {
  for (const item of shopItems) {
    if (item.active) {
      item.timer--;
      if (item.timer <= 0) {
        removePowerUp(item);
      }
    }
  }
}

// ================== Arena Battle Functions ==================
function spawnArenaWeapon() {
  if (arenaState.weapons.length < 3) {
    const type = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
    arenaState.weapons.push({
      ...type,
      x: 100 + Math.random() * 700,
      y: groundY - 20,
      spawned: frameCount
    });
  }
}

function pickupWeapon(player, isPlayer = true) {
  for (let i = arenaState.weapons.length - 1; i >= 0; i--) {
    const weapon = arenaState.weapons[i];
    const px = player.x + player.w / 2;
    const dist = Math.abs(px - weapon.x);
    if (dist < 50 && player.y >= groundY - 20) {
      if (isPlayer) {
        arenaState.currentWeapon = weapon;
      } else {
        arenaState.cpuWeapon = weapon;
      }
      arenaState.weapons.splice(i, 1);
      return true;
    }
  }
  return false;
}

function arenaAttack(attacker, defender, weapon, isPlayer) {
  if (!weapon) return;
  
  const attackerX = attacker.x + attacker.w / 2;
  const defenderX = defender.x + defender.w / 2;
  const dist = Math.abs(attackerX - defenderX);
  
  if (dist <= weapon.range) {
    const damage = weapon.damage;
    const knockback = weapon.knockback * (1 + (isPlayer ? arenaState.cpuDamage : arenaState.playerDamage) / 100);
    
    if (isPlayer) {
      arenaState.cpuHealth -= damage;
      arenaState.cpuDamage += damage;
      defender.x += (defenderX > attackerX ? 1 : -1) * knockback;
      defender.vy = -knockback * 0.5;
    } else {
      arenaState.playerHealth -= damage;
      arenaState.playerDamage += damage;
      defender.x += (defenderX > attackerX ? 1 : -1) * knockback;
      defender.vy = -knockback * 0.5;
    }
    
    spawnBurst(defenderX, defender.y + defender.h / 2, { color: "rgba(255,100,100,0.9)", count: 15 });
    playSound("spike", { intensity: 1.5 });
  }
}

function updateArena() {
  if (!arenaState.active) return;
  
  // Spawn weapons periodically
  if (frameCount % 180 === 0) spawnArenaWeapon();
  
  // Cooldowns
  if (arenaState.attackCooldown > 0) arenaState.attackCooldown--;
  if (arenaState.cpuAttackCooldown > 0) arenaState.cpuAttackCooldown--;
  
  // Player pickup
  pickupWeapon(p1, true);
  
  // CPU pickup and attack AI
  pickupWeapon(p2, false);
  if (arenaState.cpuWeapon && arenaState.cpuAttackCooldown <= 0) {
    const dist = Math.abs((p2.x + p2.w/2) - (p1.x + p1.w/2));
    if (dist < arenaState.cpuWeapon.range * 1.2) {
      arenaAttack(p2, p1, arenaState.cpuWeapon, false);
      arenaState.cpuAttackCooldown = arenaState.cpuWeapon.cooldown;
    }
  }
  
  // Check for knockout (off screen or health depleted)
  if (arenaState.playerHealth <= 0 || p1.x < -100 || p1.x > 1000) {
    arenaState.cpuHealth = 100; // CPU wins
    switchGameMode("volleyball");
  }
  if (arenaState.cpuHealth <= 0 || p2.x < -100 || p2.x > 1000) {
    playerStats.coins += 50; // Arena victory bonus
    arenaState.playerHealth = 100;
    switchGameMode("volleyball");
  }
}

// ================== Life Simulation Functions ==================
function spawnEntity(type, x, y) {
  if (simState.entities.length >= simState.maxEntities) return;
  
  const entityType = entityTypes.find(e => e.id === type);
  if (!entityType) return;
  
  simState.entities.push({
    ...entityType,
    x: x || Math.random() * 800 + 50,
    y: y || groundY,
    vx: (Math.random() - 0.5) * 2,
    vy: 0,
    currentHealth: entityType.health,
    age: 0,
    target: null
  });
}

function updateSimulation() {
  if (!simState.active) return;
  
  // Regenerate divine energy
  simState.divineEnergy = Math.min(simState.maxDivineEnergy, simState.divineEnergy + 0.05);
  
  // Update entities
  for (let i = simState.entities.length - 1; i >= 0; i--) {
    const entity = simState.entities[i];
    entity.age++;
    
    // Movement
    entity.x += entity.vx * entity.speed;
    entity.vy += 0.3;
    entity.y += entity.vy;
    
    // Ground collision
    if (entity.y > groundY) {
      entity.y = groundY;
      entity.vy = 0;
    }
    
    // Boundary wrap
    if (entity.x < 0) entity.x = 900;
    if (entity.x > 900) entity.x = 0;
    
    // Random direction change
    if (Math.random() < 0.02) {
      entity.vx = (Math.random() - 0.5) * 2;
    }
    
    // Hostile behavior
    if (entity.hostile && entity.damage) {
      for (const other of simState.entities) {
        if (other !== entity && !other.hostile) {
          const dist = Math.hypot(entity.x - other.x, entity.y - other.y);
          if (dist < 30) {
            other.currentHealth -= entity.damage * 0.1;
            if (other.currentHealth <= 0) {
              simState.entities.splice(simState.entities.indexOf(other), 1);
            }
          }
        }
      }
    }
    
    // Death from old age
    if (entity.age > 3600) { // 1 minute at 60fps
      simState.entities.splice(i, 1);
    }
  }
}

function useGodPower(power) {
  const godPower = simState.godPowers[power];
  if (!godPower || simState.divineEnergy < godPower.cost || godPower.cooldown > 0) return;
  
  simState.divineEnergy -= godPower.cost;
  godPower.cooldown = 120;
  
  switch(power) {
    case "lightning":
      // Strike random entity
      if (simState.entities.length > 0) {
        const target = simState.entities[Math.floor(Math.random() * simState.entities.length)];
        target.currentHealth -= 50;
        spawnBurst(target.x, target.y, { color: "rgba(255,255,0,0.9)", count: 20 });
        if (target.currentHealth <= 0) {
          simState.entities.splice(simState.entities.indexOf(target), 1);
        }
      }
      break;
    case "blessing":
      // Heal all friendly entities
      for (const entity of simState.entities) {
        if (!entity.hostile) {
          entity.currentHealth = Math.min(entity.health, entity.currentHealth + 20);
        }
      }
      break;
    case "plague":
      // Damage all hostile entities
      for (const entity of simState.entities) {
        if (entity.hostile) {
          entity.currentHealth -= 30;
          if (entity.currentHealth <= 0) {
            simState.entities.splice(simState.entities.indexOf(entity), 1);
          }
        }
      }
      break;
    case "earthquake":
      // Damage everything
      for (let i = simState.entities.length - 1; i >= 0; i--) {
        simState.entities[i].currentHealth -= 15;
        simState.entities[i].vy = -8;
        if (simState.entities[i].currentHealth <= 0) {
          simState.entities.splice(i, 1);
        }
      }
      cameraShake = 20;
      break;
  }
}

// ================== Evil Caterpillar Functions ==================
function updateCaterpillar() {
  if (!caterpillar.active) return;
  
  // Hunger decreases over time
  caterpillar.hunger = Math.max(0, caterpillar.hunger - 0.02);
  
  // Move towards opponent if fed enough
  if (caterpillar.targetOpponent && caterpillar.segments >= 10) {
    const targetX = p2.x + p2.w / 2;
    const dx = targetX - caterpillar.x;
    caterpillar.x += Math.sign(dx) * Math.min(2, Math.abs(dx) * 0.02);
    
    // Attack opponent if close
    if (Math.abs(dx) < 50) {
      if (frameCount % 30 === 0) {
        // In arena mode, damage health; in volleyball, give player a point
        if (arenaState.active) {
          arenaState.cpuHealth -= caterpillar.attackDamage;
        } else if (gameMode === "volleyball") {
          // Give player a point as caterpillar "eats" opponent's ability
          p1.score = Math.min(settings.targetScore, p1.score + 0.1);
        }
        spawnBurst(p2.x + p2.w/2, p2.y + p2.h/2, { color: "rgba(100,255,100,0.9)", count: 8 });
      }
    }
  }
  
  // Shrink if starving
  if (caterpillar.hunger <= 0 && frameCount % 300 === 0) {
    caterpillar.segments = Math.max(3, caterpillar.segments - 1);
  }
}

function feedCaterpillar(food = 1) {
  if (!caterpillar.active) return;
  
  caterpillar.hunger = Math.min(caterpillar.maxHunger, caterpillar.hunger + 20 * food);
  caterpillar.foodEaten += food;
  caterpillar.lastFedFrame = frameCount;
  
  // Grow if fed enough
  if (caterpillar.foodEaten >= caterpillar.growthThreshold) {
    caterpillar.segments = Math.min(caterpillar.maxSegments, caterpillar.segments + 1);
    caterpillar.foodEaten = 0;
    caterpillar.attackDamage += 2;
  }
  
  // Start targeting opponent once big enough
  if (caterpillar.segments >= 10) {
    caterpillar.targetOpponent = true;
  }
  
  playerStats.coins += 5; // Reward for feeding
}

function drawCaterpillar() {
  if (!caterpillar.active) return;
  
  ctx.save();
  const segmentSize = 12 + caterpillar.segments * 0.5;
  
  // Draw segments
  for (let i = 0; i < caterpillar.segments; i++) {
    const x = caterpillar.x - i * segmentSize * 0.8;
    const y = caterpillar.y + Math.sin(frameCount * 0.1 + i * 0.5) * 3;
    
    // Body segment
    ctx.fillStyle = i === 0 ? "#4a1" : "#3a2";
    ctx.beginPath();
    ctx.arc(x, y, segmentSize / 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Spots
    ctx.fillStyle = "#2a1";
    ctx.beginPath();
    ctx.arc(x + 2, y - 2, segmentSize / 6, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Head with eyes
  const headX = caterpillar.x;
  const headY = caterpillar.y;
  
  // Evil eyes
  ctx.fillStyle = "#ff0";
  ctx.beginPath();
  ctx.arc(headX + 4, headY - 4, 3, 0, Math.PI * 2);
  ctx.arc(headX - 4, headY - 4, 3, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = "#f00";
  ctx.beginPath();
  ctx.arc(headX + 4, headY - 4, 1.5, 0, Math.PI * 2);
  ctx.arc(headX - 4, headY - 4, 1.5, 0, Math.PI * 2);
  ctx.fill();
  
  // Antennae
  ctx.strokeStyle = "#3a2";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(headX - 3, headY - segmentSize/2);
  ctx.lineTo(headX - 8, headY - segmentSize);
  ctx.moveTo(headX + 3, headY - segmentSize/2);
  ctx.lineTo(headX + 8, headY - segmentSize);
  ctx.stroke();
  
  // Hunger bar
  ctx.fillStyle = "rgba(0,0,0,0.5)";
  ctx.fillRect(caterpillar.x - 20, caterpillar.y - 30, 40, 6);
  ctx.fillStyle = caterpillar.hunger > 30 ? "#0f0" : "#f00";
  ctx.fillRect(caterpillar.x - 20, caterpillar.y - 30, 40 * (caterpillar.hunger / caterpillar.maxHunger), 6);
  
  ctx.restore();
}

// ================== Chemistry System Functions ==================
function addElementToMix(elementId) {
  if (chemistryState.currentMix.length >= 4) return;
  
  const element = baseElements.find(e => e.id === elementId);
  if (element && chemistryState.discovered.includes(elementId)) {
    chemistryState.currentMix.push(elementId);
  }
}

function clearMix() {
  chemistryState.currentMix = [];
  chemistryState.craftingResult = null;
}

function tryCraft() {
  if (chemistryState.currentMix.length < 2) return null;
  
  // Sort for comparison
  const sorted = [...chemistryState.currentMix].sort();
  
  for (const recipe of chemistryRecipes) {
    const recipeSorted = [...recipe.inputs].sort();
    if (sorted.length === recipeSorted.length && 
        sorted.every((val, idx) => val === recipeSorted[idx])) {
      // Found a match!
      chemistryState.craftingResult = recipe;
      
      // Unlock the new element/compound
      if (!chemistryState.discovered.includes(recipe.output)) {
        chemistryState.discovered.push(recipe.output);
        playerStats.coins += 25; // Discovery bonus
        
        // Special effects for major discoveries
        if (recipe.output === "nuke") {
          cameraShake = 50;
          spawnBurst(450, 250, { color: "rgba(255,200,100,0.9)", count: 50, spread: 3, speed: 8 });
        } else if (recipe.output === "universe") {
          cameraShake = 30;
          spawnBurst(450, 250, { color: "rgba(100,100,255,0.9)", count: 100, spread: 3.14, speed: 10 });
          playerStats.coins += 500; // Massive bonus for creating the universe
        } else if (recipe.output === "life") {
          spawnBurst(450, 250, { color: "rgba(100,255,100,0.9)", count: 30, spread: 2, speed: 5 });
          // Spawn entities in simulation
          if (simState.active) {
            for (let i = 0; i < 5; i++) spawnEntity("human");
          }
        }
      }
      
      chemistryState.currentMix = [];
      return recipe;
    }
  }
  
  // No match - failed combination
  chemistryState.currentMix = [];
  return null;
}

// ================== Extended Drawing Functions ==================
function drawShop() {
  if (!showingShop) return;
  
  ctx.save();
  // Background overlay
  ctx.fillStyle = "rgba(0,0,0,0.8)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Shop panel
  ctx.fillStyle = "rgba(50,50,80,0.95)";
  ctx.fillRect(150, 50, 600, 400);
  ctx.strokeStyle = "#gold";
  ctx.lineWidth = 3;
  ctx.strokeRect(150, 50, 600, 400);
  
  // Title
  ctx.fillStyle = "#FFD700";
  ctx.font = "bold 28px Arial";
  ctx.textAlign = "center";
  ctx.fillText("‚ö° POWER-UP SHOP ‚ö°", 450, 90);
  
  // Coins display
  ctx.fillStyle = "#FFF";
  ctx.font = "18px Arial";
  ctx.fillText(`üí∞ Coins: ${playerStats.coins}`, 450, 120);
  
  // Items
  let y = 160;
  for (let i = 0; i < shopItems.length; i++) {
    const item = shopItems[i];
    const canAfford = playerStats.coins >= item.cost && !item.active;
    
    ctx.fillStyle = canAfford ? "rgba(100,150,100,0.8)" : "rgba(80,80,80,0.8)";
    if (item.active) ctx.fillStyle = "rgba(100,100,200,0.8)";
    ctx.fillRect(170, y, 560, 50);
    
    ctx.fillStyle = "#FFF";
    ctx.font = "16px Arial";
    ctx.textAlign = "left";
    ctx.fillText(`${i+1}. ${item.name}`, 180, y + 20);
    ctx.fillText(item.description, 180, y + 40);
    
    ctx.textAlign = "right";
    if (item.active) {
      ctx.fillStyle = "#0F0";
      ctx.fillText(`ACTIVE (${Math.ceil(item.timer/60)}s)`, 720, y + 30);
    } else {
      ctx.fillStyle = canAfford ? "#FFD700" : "#888";
      ctx.fillText(`${item.cost} coins`, 720, y + 30);
    }
    
    y += 55;
  }
  
  ctx.fillStyle = "#AAA";
  ctx.font = "14px Arial";
  ctx.textAlign = "center";
  ctx.fillText("Press 1-6 to buy | Press B to close shop", 450, 440);
  
  ctx.restore();
}

function drawGambling() {
  if (!showingGambling) return;
  
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.85)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Casino panel
  ctx.fillStyle = "rgba(80,20,20,0.95)";
  ctx.fillRect(150, 50, 600, 400);
  ctx.strokeStyle = "#FFD700";
  ctx.lineWidth = 4;
  ctx.strokeRect(150, 50, 600, 400);
  
  // Title
  ctx.fillStyle = "#FFD700";
  ctx.font = "bold 32px Arial";
  ctx.textAlign = "center";
  ctx.fillText("üé∞ CASINO üé∞", 450, 95);
  
  ctx.fillStyle = "#FFF";
  ctx.font = "20px Arial";
  ctx.fillText(`üí∞ Coins: ${playerStats.coins}`, 450, 130);
  
  // Slot machine
  ctx.fillStyle = "rgba(40,40,60,0.9)";
  ctx.fillRect(250, 150, 400, 100);
  
  const symbols = ["üçí", "üçã", "üçä", "üíé", "7Ô∏è‚É£", "‚≠ê"];
  ctx.font = "48px Arial";
  for (let i = 0; i < 3; i++) {
    const symbol = playerStats.slotSpinning ? 
      symbols[Math.floor(Math.random() * symbols.length)] : 
      symbols[playerStats.slotResults[i]];
    ctx.fillText(symbol, 320 + i * 120, 215);
  }
  
  // Instructions
  ctx.fillStyle = "#FFF";
  ctx.font = "16px Arial";
  ctx.fillText("Press S to Spin Slots (10 coins)", 450, 280);
  ctx.fillText("Press D to Roll Dice (5 coins)", 450, 305);
  ctx.fillText("Press V to Bet on Next Match (20 coins)", 450, 330);
  
  if (playerStats.lastDiceRoll > 0) {
    ctx.fillStyle = "#FFD700";
    ctx.fillText(`Last Dice Roll: ${playerStats.lastDiceRoll}`, 450, 360);
  }
  
  if (playerStats.currentBet > 0) {
    ctx.fillStyle = "#0F0";
    ctx.fillText(`Current Match Bet: ${playerStats.currentBet} coins`, 450, 385);
  }
  
  ctx.fillStyle = "#AAA";
  ctx.font = "14px Arial";
  ctx.fillText("Press G to close casino", 450, 430);
  
  ctx.restore();
}

function drawChemistry() {
  if (!showingChemistry) return;
  
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.85)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Chemistry lab panel
  ctx.fillStyle = "rgba(20,40,60,0.95)";
  ctx.fillRect(100, 30, 700, 440);
  ctx.strokeStyle = "#00FFFF";
  ctx.lineWidth = 3;
  ctx.strokeRect(100, 30, 700, 440);
  
  // Title
  ctx.fillStyle = "#00FFFF";
  ctx.font = "bold 28px Arial";
  ctx.textAlign = "center";
  ctx.fillText("‚öóÔ∏è CHEMISTRY LAB ‚öóÔ∏è", 450, 65);
  
  ctx.fillStyle = "#FFF";
  ctx.font = "14px Arial";
  ctx.fillText(`Discovered: ${chemistryState.discovered.length}/${baseElements.length + chemistryRecipes.length}`, 450, 90);
  
  // Elements grid
  ctx.fillStyle = "#AAA";
  ctx.font = "12px Arial";
  ctx.fillText("Elements (Press number to add):", 250, 115);
  
  let x = 120, y = 130;
  for (let i = 0; i < baseElements.length; i++) {
    const elem = baseElements[i];
    const unlocked = chemistryState.discovered.includes(elem.id);
    
    ctx.fillStyle = unlocked ? elem.color : "#333";
    ctx.fillRect(x, y, 60, 60);
    ctx.strokeStyle = unlocked ? "#FFF" : "#555";
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, 60, 60);
    
    ctx.fillStyle = unlocked ? "#FFF" : "#555";
    ctx.font = "bold 20px Arial";
    ctx.textAlign = "center";
    ctx.fillText(elem.symbol, x + 30, y + 30);
    ctx.font = "10px Arial";
    ctx.fillText(`[${i + 1}]`, x + 30, y + 50);
    
    x += 70;
    if (x > 750) { x = 120; y += 70; }
  }
  
  // Mixing area
  ctx.fillStyle = "rgba(60,60,80,0.8)";
  ctx.fillRect(120, 280, 300, 80);
  ctx.strokeStyle = "#88F";
  ctx.strokeRect(120, 280, 300, 80);
  
  ctx.fillStyle = "#FFF";
  ctx.font = "14px Arial";
  ctx.textAlign = "left";
  ctx.fillText("Mixing:", 130, 300);
  
  // Show current mix
  let mixX = 130;
  for (const elemId of chemistryState.currentMix) {
    const elem = baseElements.find(e => e.id === elemId);
    if (elem) {
      ctx.fillStyle = elem.color;
      ctx.beginPath();
      ctx.arc(mixX + 15, 335, 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#FFF";
      ctx.font = "bold 14px Arial";
      ctx.textAlign = "center";
      ctx.fillText(elem.symbol, mixX + 15, 340);
      mixX += 40;
    }
  }
  
  // Result area
  ctx.fillStyle = "rgba(60,80,60,0.8)";
  ctx.fillRect(450, 280, 330, 80);
  ctx.strokeStyle = "#8F8";
  ctx.strokeRect(450, 280, 330, 80);
  
  ctx.fillStyle = "#FFF";
  ctx.font = "14px Arial";
  ctx.textAlign = "left";
  ctx.fillText("Result:", 460, 300);
  
  if (chemistryState.craftingResult) {
    ctx.fillStyle = chemistryState.craftingResult.color;
    ctx.font = "bold 18px Arial";
    ctx.fillText(chemistryState.craftingResult.name, 460, 335);
    ctx.fillStyle = "#0F0";
    ctx.font = "12px Arial";
    ctx.fillText("SUCCESS! +25 coins", 460, 355);
  }
  
  // Discovered compounds
  ctx.fillStyle = "#AAA";
  ctx.font = "12px Arial";
  ctx.textAlign = "center";
  ctx.fillText("Discovered compounds:", 450, 385);
  
  let compX = 150;
  for (const recipe of chemistryRecipes) {
    if (chemistryState.discovered.includes(recipe.output)) {
      ctx.fillStyle = recipe.color;
      ctx.font = "10px Arial";
      ctx.fillText(recipe.name, compX, 410);
      compX += 80;
      if (compX > 750) break;
    }
  }
  
  // Instructions
  ctx.fillStyle = "#AAA";
  ctx.font = "14px Arial";
  ctx.textAlign = "center";
  ctx.fillText("Enter to Craft | Backspace to Clear | C to close lab", 450, 455);
  
  ctx.restore();
}

function drawSimulation() {
  if (!simState.active) return;
  
  // Draw entities
  for (const entity of simState.entities) {
    ctx.save();
    ctx.fillStyle = entity.color;
    ctx.beginPath();
    ctx.arc(entity.x, entity.y - 10, 8, 0, Math.PI * 2);
    ctx.fill();
    
    // Health bar
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(entity.x - 10, entity.y - 25, 20, 4);
    ctx.fillStyle = entity.currentHealth > entity.health * 0.3 ? "#0F0" : "#F00";
    ctx.fillRect(entity.x - 10, entity.y - 25, 20 * (entity.currentHealth / entity.health), 4);
    
    ctx.restore();
  }
  
  // Draw UI
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.7)";
  ctx.fillRect(5, 80, 150, 120);
  
  ctx.fillStyle = "#FFF";
  ctx.font = "12px Arial";
  ctx.textAlign = "left";
  ctx.fillText(`Entities: ${simState.entities.length}/${simState.maxEntities}`, 10, 95);
  ctx.fillText(`Divine Energy: ${Math.floor(simState.divineEnergy)}`, 10, 115);
  
  ctx.fillStyle = "#AAA";
  ctx.font = "10px Arial";
  ctx.fillText("Z-Spawn | X-Lightning", 10, 135);
  ctx.fillText("N-Blessing | M-Plague", 10, 150);
  ctx.fillText(",-Earthquake", 10, 165);
  ctx.fillText("I-Toggle Simulation", 10, 180);
  
  ctx.restore();
}

function drawArenaUI() {
  if (!arenaState.active) return;
  
  ctx.save();
  
  // Player health
  ctx.fillStyle = "rgba(0,0,0,0.7)";
  ctx.fillRect(20, 50, 200, 30);
  ctx.fillStyle = "#0F0";
  ctx.fillRect(22, 52, 196 * (arenaState.playerHealth / 100), 26);
  ctx.fillStyle = "#FFF";
  ctx.font = "14px Arial";
  ctx.textAlign = "left";
  ctx.fillText(`P1: ${Math.floor(arenaState.playerHealth)}%`, 30, 70);
  ctx.fillText(`DMG: ${arenaState.playerDamage}%`, 130, 70);
  
  // CPU health
  ctx.fillStyle = "rgba(0,0,0,0.7)";
  ctx.fillRect(680, 50, 200, 30);
  ctx.fillStyle = "#F00";
  ctx.fillRect(682, 52, 196 * (arenaState.cpuHealth / 100), 26);
  ctx.fillStyle = "#FFF";
  ctx.textAlign = "right";
  ctx.fillText(`CPU: ${Math.floor(arenaState.cpuHealth)}%`, 870, 70);
  ctx.fillText(`DMG: ${arenaState.cpuDamage}%`, 770, 70);
  
  // Weapons on ground
  for (const weapon of arenaState.weapons) {
    ctx.fillStyle = weapon.color;
    ctx.fillRect(weapon.x - 10, weapon.y - 5, 20, 10);
    ctx.fillStyle = "#FFF";
    ctx.font = "10px Arial";
    ctx.textAlign = "center";
    ctx.fillText(weapon.name, weapon.x, weapon.y - 10);
  }
  
  // Current weapon display
  if (arenaState.currentWeapon) {
    ctx.fillStyle = "#FFF";
    ctx.font = "12px Arial";
    ctx.textAlign = "left";
    ctx.fillText(`Weapon: ${arenaState.currentWeapon.name}`, 20, 100);
    ctx.fillText("Press Space to Attack", 20, 115);
  }
  
  ctx.restore();
}

function drawModeSelector() {
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(300, 5, 300, 20);
  
  ctx.fillStyle = "#FFF";
  ctx.font = "11px Arial";
  ctx.textAlign = "center";
  ctx.fillText(`Mode: ${gameMode.toUpperCase()} | T-Toggle | B-Shop | G-Casino | C-Chem | K-Caterpillar`, 450, 18);
  ctx.restore();
}

const maps = [
  {
    name: "Sunny Bay",
    sky: ["#8bd5ff", "#5ba9f5", "#2a4f7f"],
    sun: { main: "rgba(255,241,200,0.95)", halo: "rgba(255,205,120,0.7)", radius: 120, alpha: 1 },
    raysAlpha: 0.16,
    cloudColor: "rgba(255,255,255,0.78)",
    horizon: ["rgba(255,230,180,0.4)", "rgba(255,230,180,0)"],
    water: ["#1d4f87", "#163c6e"],
    sand: ["#f5e1b8", "#e0c58f"],
    crowdBase: "#1f2b33",
    crowdAccent: "rgba(255,255,255,0.07)",
    vignetteAlpha: 0.22
  },
  {
    name: "Sunset Pier",
    sky: ["#ffcf9f", "#ff8a7a", "#5c2c5f"],
    sun: { main: "rgba(255,180,120,0.9)", halo: "rgba(255,120,120,0.65)", radius: 140, alpha: 1 },
    raysAlpha: 0.22,
    cloudColor: "rgba(255,255,255,0.7)",
    horizon: ["rgba(255,160,140,0.45)", "rgba(255,160,140,0)"],
    water: ["#5a2b78", "#2f1f52"],
    sand: ["#f2c18a", "#d4976b"],
    crowdBase: "#2a1f33",
    crowdAccent: "rgba(255,200,200,0.08)",
    vignetteAlpha: 0.26
  },
  {
    name: "Neon Night",
    sky: ["#132040", "#0c122d", "#050712"],
    sun: { main: "rgba(120,200,255,0.35)", halo: "rgba(120,120,255,0.25)", radius: 90, alpha: 0.6 },
    raysAlpha: 0.06,
    cloudColor: "rgba(200,220,255,0.28)",
    horizon: ["rgba(120,160,255,0.18)", "rgba(120,160,255,0)"],
    water: ["#182c5c", "#0f1c42"],
    sand: ["#2a2e3a", "#1b1f2c"],
    crowdBase: "#0f1220",
    crowdAccent: "rgba(120,200,255,0.08)",
    vignetteAlpha: 0.32
  },
  {
    name: "Arena Hardwood",
    indoor: true,
    sky: ["#222630", "#1b1f2a", "#10141f"],
    sun: { main: "rgba(255,255,255,0.2)", halo: "rgba(255,255,255,0.12)", radius: 90, alpha: 0 },
    raysAlpha: 0,
    cloudColor: "rgba(255,255,255,0.06)",
    horizon: ["rgba(255,220,180,0.12)", "rgba(255,220,180,0)"],
    water: ["#1a2335", "#11182b"],
    sand: ["#c89b58", "#9b7238"],
    crowdBase: "#0f111a",
    crowdAccent: "rgba(255,255,255,0.05)",
    vignetteAlpha: 0.28
  },
  {
    name: "Campus Gym",
    indoor: true,
    sky: ["#2c3a52", "#232c3f", "#171d2c"],
    sun: { main: "rgba(255,255,240,0.75)", halo: "rgba(255,220,150,0.4)", radius: 120, alpha: 0.55 },
    raysAlpha: 0.08,
    cloudColor: "rgba(255,255,255,0.06)",
    horizon: ["rgba(220,210,200,0.18)", "rgba(220,210,200,0)"],
    water: ["#1b2538", "#141c2c"],
    sand: ["#d1b07a", "#b78c53"],
    crowdBase: "#111622",
    crowdAccent: "rgba(80,180,255,0.06)",
    vignetteAlpha: 0.3
  }
];
// Fixed-step timing to avoid refresh-rate speedups
const STEP = CONFIG.STEP_MS;
let lastTime = performance.now();
let accumulator = 0;

document.addEventListener("keydown", e => {
  const key = (e.key || "").toLowerCase();
  if (key === "m") {
    masterVolume = masterVolume > 0 ? 0 : settings.soundLevel;
    return;
  }
  if (key === "p" || key === "escape") {
    paused = !paused;
    keys = {};
    lastTime = performance.now();
    return;
  }

  // Pause-menu toggles
  if (paused) {
    if (key === "1") {
      const levels = [1, 0.6, 0];
      const idx = levels.findIndex(v => Math.abs(v - settings.soundLevel) < 0.001);
      settings.soundLevel = levels[(idx + 1) % levels.length];
      masterVolume = settings.soundLevel;
      return;
    }
    if (key === "2") {
      settings.fxTrails = !settings.fxTrails;
      return;
    }
    if (key === "3") {
      settings.fxParticles = !settings.fxParticles;
      return;
    }
    if (key === "4") {
      settings.screenShake = !settings.screenShake;
      if (!settings.screenShake) cameraShake = 0;
      return;
    }
    if (key === "5") {
      settings.trailStyle = settings.trailStyle === "glow" ? "ember" : "glow";
      return;
    }
    if (key === "6") {
      settings.soundStyle = settings.soundStyle === "bright" ? "soft" : "bright";
      return;
    }
    if (key === "7") {
      const modes = ["easy", "normal", "hard"];
      const idx = modes.indexOf(settings.botDifficulty);
      settings.botDifficulty = modes[(idx + 1) % modes.length];
      applyBotDifficulty();
      return;
    }
    if (key === "8") {
      const lengths = [10, 15, 21];
      const idx = lengths.indexOf(settings.targetScore);
      settings.targetScore = lengths[(idx + 1) % lengths.length];
      return;
    }
    if (key === "9") {
      settings.mapIndex = (settings.mapIndex + 1) % maps.length;
      return;
    }
  }
  if (key === "shift") {
    e.preventDefault();
    keys["shift"] = true; // tracked but unused
    return;
  }
  
  // Extended game controls (when not paused)
  if (!paused) {
    // Toggle Shop
    if (key === "b") {
      showingShop = !showingShop;
      showingGambling = false;
      showingChemistry = false;
      return;
    }
    
    // Toggle Gambling/Casino
    if (key === "g" && !showingShop && !showingChemistry) {
      showingGambling = !showingGambling;
      return;
    }
    
    // Toggle Chemistry Lab
    if (key === "c" && !showingShop && !showingGambling) {
      showingChemistry = !showingChemistry;
      return;
    }
    
    // Toggle Caterpillar
    if (key === "k") {
      caterpillar.active = !caterpillar.active;
      if (caterpillar.active) {
        caterpillar.x = 100;
        caterpillar.hunger = 50;
      }
      return;
    }
    
    // Feed Caterpillar
    if (key === "l" && caterpillar.active) {
      feedCaterpillar();
      return;
    }
    
    // Toggle game modes
    if (key === "t") {
      const modes = ["volleyball", "arena", "simulation"];
      const idx = modes.indexOf(gameMode);
      switchGameMode(modes[(idx + 1) % modes.length]);
      return;
    }
    
    // Shop purchases (1-6)
    if (showingShop) {
      const num = parseInt(key);
      if (num >= 1 && num <= 6) {
        buyPowerUp(shopItems[num - 1].id);
        return;
      }
    }
    
    // Gambling controls
    if (showingGambling) {
      if (key === "s") { spinSlots(); return; }
      if (key === "d") { rollDice(); return; }
      if (key === "v") { betOnMatch(20); return; }
    }
    
    // Chemistry controls
    if (showingChemistry) {
      const num = parseInt(key);
      if (num >= 1 && num <= 8) {
        addElementToMix(baseElements[num - 1].id);
        return;
      }
      if (key === "enter") { tryCraft(); return; }
      if (key === "backspace") { clearMix(); return; }
    }
    
    // Simulation controls
    if (simState.active) {
      if (key === "z") { spawnEntity(simState.spawnType); return; }
      if (key === "x") { useGodPower("lightning"); return; }
      if (key === "n") { useGodPower("blessing"); return; }
      if (key === ",") { useGodPower("earthquake"); return; }
      if (key === "i") { 
        simState.active = false;
        switchGameMode("volleyball");
        return;
      }
    }
    
    // Arena attack
    if (arenaState.active && (key === " " || key === "space") && arenaState.attackCooldown <= 0) {
      if (arenaState.currentWeapon) {
        arenaAttack(p1, p2, arenaState.currentWeapon, true);
        arenaState.attackCooldown = arenaState.currentWeapon.cooldown;
      }
    }
  }
  
  keys[key] = true;
});
document.addEventListener("keyup", e => {
  const key = (e.key || "").toLowerCase();
  keys[key] = false;
});

// ================== Sound + FX System ==================
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

function playTone(freq = CONFIG.AUDIO_DEFAULT_FREQ, duration = CONFIG.AUDIO_DEFAULT_DURATION, {
  type = "sine",
  volume = 0.25,
  attack = CONFIG.AUDIO_DEFAULT_ATTACK,
  decay = CONFIG.AUDIO_DEFAULT_DECAY,
  sweep = 0
} = {}) {
  if (masterVolume <= 0) return;
  try {
    const styleScale = settings.soundStyle === "soft" ? 0.8 : 1;
    volume *= masterVolume * styleScale;
    const ctx = ensureAudio();
    const now = ctx.currentTime;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = type;
    osc.frequency.setValueAtTime(freq, now);
    if (sweep !== 0) {
      osc.frequency.exponentialRampToValueAtTime(Math.max(40, freq * sweep), now + duration);
    }

    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.linearRampToValueAtTime(volume, now + attack);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + Math.max(duration, decay));

    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start(now);
    osc.stop(now + Math.max(duration, decay) + 0.02);
  } catch (e) { /* ignore */ }
}

function playNoise(duration = CONFIG.AUDIO_NOISE_DURATION, volume = CONFIG.AUDIO_NOISE_VOLUME, {type = "white"} = {}) {
  if (masterVolume <= 0) return;
  try {
    volume *= masterVolume * (settings.soundStyle === "soft" ? 0.72 : 1);
    const ctx = ensureAudio();
    const bufferSize = Math.max(1, Math.floor(ctx.sampleRate * duration));
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      data[i] = (Math.random() * 2 - 1) * (type === "pink" ? Math.random() : 1);
    }
    const noise = ctx.createBufferSource();
    noise.buffer = buffer;
    const gain = ctx.createGain();
    const now = ctx.currentTime;
    gain.gain.setValueAtTime(volume, now);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
    noise.connect(gain);
    gain.connect(ctx.destination);
    noise.start(now);
    noise.stop(now + duration + 0.02);
  } catch (e) { /* ignore */ }
}

function playSound(name = "ping", { intensity = 1 } = {}) {
  const toneType = settings.soundStyle === "soft" ? "sine" : "triangle";
  const percussive = settings.soundStyle === "soft" ? "sine" : "sawtooth";
  const accentVol = (settings.soundStyle === "soft" ? 0.18 : 0.24) * intensity;
  switch (name) {
    case "receive":
      playTone(540, 0.09, { type: toneType, volume: 0.22 * intensity });
      playTone(420, 0.11, { type: "sine", volume: 0.14 * intensity });
      break;
    case "set":
      playTone(610, 0.12, { type: "sine", volume: accentVol });
      playTone(880, 0.14, { type: toneType, volume: 0.12 * intensity, sweep: 1.15 });
      break;
    case "spike":
      playTone(320, 0.08, { type: percussive, volume: 0.28 * intensity, sweep: 0.6 });
      playNoise(0.08, 0.12 * intensity, { type: "pink" });
      break;
    case "feint":
      playTone(500, 0.1, { type: toneType, volume: 0.2 * intensity });
      break;
    case "score":
      playTone(520, 0.16, { type: toneType, volume: 0.25 * intensity });
      playTone(780, 0.16, { type: "sine", volume: 0.18 * intensity });
      setTimeout(() => playTone(660, 0.14, { type: "sine", volume: 0.18 * intensity }), 80);
      break;
    case "net":
      playTone(260, 0.08, { type: "sine", volume: 0.18 * intensity });
      playNoise(0.05, 0.08 * intensity);
      break;
    case "superSpike":
      playTone(220, 0.12, { type: percussive, volume: 0.32 * intensity, sweep: 0.55 });
      playTone(520, 0.16, { type: settings.soundStyle === "soft" ? "triangle" : "square", volume: 0.22 * intensity, sweep: 0.4 });
      playNoise(0.1, 0.16 * intensity, { type: "pink" });
      break;
    case "whoosh":
      playNoise(0.08, 0.1 * intensity, { type: "pink" });
      playTone(180, 0.05, { type: "sine", volume: 0.12 * intensity, sweep: 0.5 });
      break;
    case "land":
      playNoise(0.08, 0.12 * intensity, { type: "pink" });
      playTone(160, 0.05, { type: "sine", volume: 0.12 * intensity });
      break;
    default:
      playTone(440, 0.09, { type: "square", volume: 0.16 });
  }
}

function distance(x1, y1, x2, y2) {
  let dx = x1 - x2;
  let dy = y1 - y2;
  return Math.sqrt(dx*dx + dy*dy);
}

// ================== FX Helpers ==================
const fxTrails = [];
const fxParticles = [];

function spawnTrail(x, y, vx, vy) {
  if (!settings.fxTrails) return;
  const speed = Math.hypot(vx, vy);
  if (speed < 3) return;
  fxTrails.push({ x, y, alpha: 0.32, scale: 1 + Math.min(0.8, speed / 10), life: 14, style: settings.trailStyle, speed });
}

function spawnBurst(x, y, { color = "rgba(255,255,255,0.9)", count = 12, spread = 2.4, speed = 3.8, gravity: g = 0.25, size = 4 } = {}) {
  if (!settings.fxParticles) return;
  for (let i = 0; i < count; i++) {
    const ang = Math.random() * Math.PI * spread - Math.PI * spread / 2;
    const mag = speed * (0.5 + Math.random() * 0.7);
    fxParticles.push({
      x,
      y,
      vx: Math.cos(ang) * mag,
      vy: Math.sin(ang) * mag,
      g,
      alpha: 0.9,
      size: size * (0.6 + Math.random() * 0.8),
      color,
      life: 22
    });
  }
}

function spawnDust(x, y, dir = 0) {
  spawnBurst(x, y, { color: "rgba(245, 203, 147, 0.9)", count: 10, spread: 1.6, speed: 2.3 + Math.abs(dir) * 0.4, gravity: 0.4, size: 5 });
}

function updateFX() {
  for (let i = fxTrails.length - 1; i >= 0; i--) {
    const t = fxTrails[i];
    t.alpha *= CONFIG.TRAIL_OPACITY_DECAY;
    t.scale *= CONFIG.PARTICLE_OPACITY_DECAY;
    t.life -= 1;
    if (t.life <= 0 || t.alpha < 0.02) fxTrails.splice(i, 1);
  }

  for (let i = fxParticles.length - 1; i >= 0; i--) {
    const p = fxParticles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += p.g;
    p.alpha *= CONFIG.PARTICLE_SIZE_DECAY;
    p.life -= 1;
    if (p.life <= 0 || p.alpha < 0.03) fxParticles.splice(i, 1);
  }
}

function drawFX() {
  // trails behind the ball
  for (const t of fxTrails) {
    ctx.save();
    ctx.globalAlpha = t.alpha;
    const grad = ctx.createRadialGradient(t.x, t.y, 2, t.x, t.y, 18 * t.scale);
    const speed = t.speed || 0;
    if (t.style === "ember") {
      const core = speed > 11 ? "rgba(255,230,180,0.95)" : "rgba(255,220,120,0.9)";
      const rim = speed > 11 ? "rgba(255,110,80,0)" : "rgba(255,80,80,0)";
      grad.addColorStop(0, core);
      grad.addColorStop(1, rim);
    } else {
      const core = speed > 11 ? "rgba(140,210,255,0.95)" : "rgba(255,255,255,0.85)";
      const rim = speed > 11 ? "rgba(255,120,230,0)" : "rgba(82, 177, 255, 0)";
      grad.addColorStop(0, core);
      grad.addColorStop(1, rim);
    }
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(t.x, t.y, 18 * t.scale, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // particles on top
  for (const p of fxParticles) {
    ctx.save();
    ctx.globalAlpha = p.alpha;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

// ================== Player Class ==================
class Player {
  constructor(x, side, isBot = false, color = CONFIG.PLAYER_COLOR) {
    this.startX = x;
    this.x = x;
    this.y = groundY;
    this.w = CONFIG.PLAYER_WIDTH;
    this.h = CONFIG.PLAYER_HEIGHT;
    this.vx = 0;
    this.vy = 0;
    this.speed = CONFIG.PLAYER_SPEED;
    this.jumpPower = CONFIG.PLAYER_JUMP_POWER;
    this.score = 0;
    this.side = side;
    this.isBot = isBot;
    this.color = color;
    this.lastHitFrame = {};
    this.wasGrounded = true;
    this.stamina = CONFIG.PLAYER_MAX_STAMINA;
    this.maxStamina = CONFIG.PLAYER_MAX_STAMINA;
    this.netHangFrames = 0;
    this.netInteractCount = 0;
    this.netInteractWindowStart = -999;
    this.netInteractCooldown = 0;
    this.diveTimer = 0;
    this.diveDir = 1;
    this.diveCooldown = 0;
    this.postDiveStun = 0;
    this.sprinting = false;

    // Bot tuning: keep speed up but avoid floaty hang time
    if (this.isBot) {
      this.speed = CONFIG.BOT_SPEED;
      this.jumpPower = CONFIG.BOT_JUMP_POWER;
    }
  }

  resetPosition() {
    this.x = this.startX;
    this.y = groundY;
    this.vy = 0;
    this.lastHitFrame = {};
    this.wasGrounded = true;
    this.stamina = this.maxStamina;
    this.netHangFrames = 0;
    this.netInteractCount = 0;
    this.netInteractWindowStart = -999;
    this.netInteractCooldown = 0;
  }

  isGrounded() {
    return this.y >= groundY - 0.1;
  }

  update(leftKey, rightKey, jumpKey) {
    const prevX = this.x;
    const wasGrounded = this.wasGrounded;
    let speedMod = 1;
    let jumpMod = 1;
    this.sprinting = false;

    if (this.netInteractCooldown > 0) {
      this.netInteractCooldown -= 1;
    }

    if (!this.isBot) {
      if (this.diveCooldown > 0) this.diveCooldown -= 1;
      if (this.postDiveStun > 0) this.postDiveStun -= 1;
      const isSprinting = keys["shift"] && this.stamina > 0;

      if (isSprinting) {
        // Holding Shift = faster movement + slightly higher jump, drains stamina
        speedMod = 1.35;   // 35% faster movement
        jumpMod = 1.08;    // 8% higher jump
        this.sprinting = true;

        const drain = this.isGrounded() ? 0.32 : 0.42;
        this.stamina = Math.max(0, this.stamina - drain);
      } else {
        // Recharge only when not sprinting (air or ground)
        const regenRate = 0.32;
        this.stamina = Math.min(this.maxStamina, this.stamina + regenRate);
      }
    }

    if (!this.isBot) {

        // Horizontal movement
        const stunned = this.postDiveStun > 0;

        if (!stunned) {
          if (keys[leftKey]) {
              this.x -= this.speed * speedMod;
          } 
          if (keys[rightKey]) {
              this.x += this.speed * speedMod;
          }
        }

        // Dive trigger (F) when grounded or very low
        if ((keys["f"] || keys[" "] === "f") && this.diveTimer <= 0 && this.diveCooldown <= 0 && this.postDiveStun <= 0 && this.y >= groundY - 6 && this.stamina >= 55) {
          const dir = keys[leftKey] ? -1 : (keys[rightKey] ? 1 : (this.side === "left" ? 1 : -1));
          this.diveDir = dir;
          this.diveTimer = 16;
          this.diveCooldown = 22; // heavier spam lockout
          this.stamina = Math.max(0, this.stamina - 55);
          this.vy = Math.min(this.vy, -2.5);
          this.lastHitFrame["dive"] = frameCount;
        }

        // Jump (Arrow Up or Space) ‚Äì still only when grounded and not diving
        const jumpPressed = keys[jumpKey] || keys[" "];
        if (jumpPressed && this.isGrounded() && this.diveTimer <= 0 && this.postDiveStun <= 0) {
          this.vy = -this.jumpPower * jumpMod;
        }
    }



    // Dive slide
    const prevDive = this.diveTimer;
    if (this.diveTimer > 0) {
      const slideScale = (this.diveTimer / 16);
      this.x += this.diveDir * this.speed * 1.6 * slideScale;
      this.diveTimer -= 1;
    }

    this.vy += gravity;
    this.y += this.vy;

    // Post-dive stun when landing from a dive
    if (prevDive > 0 && this.diveTimer <= 0 && this.postDiveStun <= 0) {
      this.postDiveStun = 16;
    }

    if (this.y > groundY) {
      this.y = groundY;
      if (!wasGrounded && this.vy > 6) {
        const cx = this.x + this.w / 2;
        spawnDust(cx, groundY + this.h - 6, this.vx || 0);
        playSound("land");
      }
      this.vy = 0;
      this.wasGrounded = true;
    } else {
      this.wasGrounded = false;
    }

    // Side clamps
    const netBand = 20;
    if (this.side === "left") {
      const nearNet = (this.x + this.w) > netLeft - netBand;
      this.netHangFrames = nearNet ? this.netHangFrames + 1 : 0;
      if (nearNet && this.netHangFrames > 24) {
        const push = 0.25 + Math.min(0.6, (this.netHangFrames - 24) * 0.02);
        this.x = Math.max(0, this.x - push);
      }
      this.x = Math.min(this.x, netLeft - this.w);
    }
    if (this.side === "right") {
      const nearNet = this.x < netRight + netBand;
      this.netHangFrames = nearNet ? this.netHangFrames + 1 : 0;
      if (nearNet && this.netHangFrames > 24) {
        const push = 0.25 + Math.min(0.6, (this.netHangFrames - 24) * 0.02);
        this.x = Math.min(canvas.width - this.w, this.x + push);
      }
      this.x = Math.max(this.x, netRight);
    }

    // Screen clamp
    this.x = Math.max(0, Math.min(this.x, canvas.width - this.w));

    // Track horizontal velocity for animation/state cues
    this.vx = this.x - prevX;
  }

  draw() {
    // Use 3D renderer if enabled
    if (renderer3D.enabled) {
      draw3DCharacter(this);
      ctx.restore();
      return;
    }
    
    ctx.save();

    // Ground shadow
    const shadowX = this.x + this.w / 2;
    const shadowY = groundY + this.h + 14; // slightly below feet on the sand
    const shadowRadX = 32;
    const shadowRadY = 8;
    ctx.fillStyle = "rgba(0,0,0,0.22)";
    ctx.beginPath();
    ctx.ellipse(shadowX, shadowY, shadowRadX, shadowRadY, 0, 0, Math.PI * 2);
    ctx.fill();

    // squash/stretch based on vertical speed
    let stretch = Math.min(Math.max(this.vy * -0.03, -0.2), 0.25);

    // Animation state flags
    const recent = (t, window = 14) => frameCount - ((this.lastHitFrame && this.lastHitFrame[t]) || -999) <= window;
    const horizontalSpeed = this.vx || 0;
    const moving = Math.abs(horizontalSpeed) > 0.5;
    const grounded = this.isGrounded();
    const diving = this.diveTimer > 0 || recent("dive", 18);
    const jumping = !grounded && this.vy < -2 && !diving;
    const falling = !grounded && this.vy > 1 && !diving;
    const stunned = this.postDiveStun > 0;
    const sideDir = this.side === "left" ? 1 : -1;
    const spikePose = recent("spike", 18);
    const setPose = !spikePose && recent("set", 18);
    const feintPose = !spikePose && recent("feint", 18);
    const receivePose = !spikePose && !feintPose && recent("receive", 14);
    const isWinner = gameOver && ((this.side === "left" ? p1.score > p2.score : p2.score > p1.score));
    const isLoser = gameOver && !isWinner;

    // lean when moving (player only) or state-driven
    let lean = 0;
    if (!this.isBot) {
      if (diving) {
        lean = this.diveDir > 0 ? 0.8 : -0.8;
        stretch = 0.05;
      } else if (stunned) {
        lean = 0;
      } else if (spikePose) {
        lean = sideDir > 0 ? 0.22 : -0.22;
      } else if (setPose) {
        lean = 0.05 * sideDir;
      } else if (feintPose || receivePose) {
        lean = sideDir * 0.05;
      } else if (jumping) {
        lean = sideDir * 0.06;
      } else if (moving) {
        lean = Math.sign(horizontalSpeed) * 0.12;
      }
    }

    if (isWinner) {
      lean = sideDir * 0.1;
      stretch = -0.08;
    } else if (isLoser) {
      lean = sideDir * -0.08;
      stretch = 0.12;
    }

  
      // --- Tame extreme downward speed so hits aren‚Äôt a 1-frame window ---
      if (this.vy > 12) {
        this.vy *= 0.985; // slight damping
      }
    ctx.translate(this.x + this.w / 2, this.y + this.h / 2);
    ctx.rotate(lean);
    ctx.scale(1 + stretch, 1 - stretch);
    ctx.translate(-(this.x + this.w / 2), -(this.y + this.h / 2));

    // Sprite-like drawing (head, body, limbs)
    const headRadius = 12;
    const headX = this.x + this.w / 2;
    const headY = this.y + 10;

    // Body gradient + accents
    const bodyGrad = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.h);
    bodyGrad.addColorStop(0, this.color);
    bodyGrad.addColorStop(0.5, "#1a2a44");
    bodyGrad.addColorStop(1, "#0e1624");
    ctx.fillStyle = bodyGrad;
    ctx.strokeStyle = "rgba(0,0,0,0.45)";
    ctx.lineWidth = 2;
    ctx.fillRect(this.x + 8, this.y + 20, this.w - 16, this.h - 25);
    ctx.strokeRect(this.x + 8, this.y + 20, this.w - 16, this.h - 25);

    // Jersey stripe
    ctx.fillStyle = "rgba(255,255,255,0.35)";
    ctx.fillRect(this.x + 10, this.y + 26, this.w - 20, 8);
    ctx.fillStyle = "rgba(255,255,255,0.22)";
    ctx.fillRect(this.x + 10, this.y + 46, this.w - 20, 5);

    // Head with subtle shading
    const headGrad = ctx.createRadialGradient(headX - 4, headY - 4, 3, headX, headY, headRadius + 3);
    headGrad.addColorStop(0, "#ffe6c8");
    headGrad.addColorStop(1, "#eec093");
    ctx.beginPath();
    ctx.arc(headX, headY, headRadius, 0, Math.PI * 2);
    ctx.fillStyle = headGrad;
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,0.25)";
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Eyes
    ctx.fillStyle = "#0b0b0b";
    ctx.fillRect(headX - 5, headY - 3, 2, 2);
    ctx.fillRect(headX + 3, headY - 3, 2, 2);

    // Limb helpers for simple pose animation with joints
    const mirror = (ang) => sideDir > 0 ? ang : Math.PI - ang; // mirror around vertical for right-side
    const limbEnd = (sx, sy, angle, len) => ({ x: sx + Math.cos(angle) * len, y: sy + Math.sin(angle) * len });
    const limbChain = (sx, sy, angle, bend, upper, lower) => {
      const knee = limbEnd(sx, sy, angle, upper);
      const foot = limbEnd(knee.x, knee.y, angle + bend, lower);
      return { knee, foot };
    };

    // Pose selection
    const runCycle = grounded && moving ? Math.sin(frameCount * 0.25 + (sideDir > 0 ? 0 : Math.PI)) : 0;

    const lerp = (a, b, t) => a + (b - a) * t;
    const spikeAge = frameCount - ((this.lastHitFrame && this.lastHitFrame["spike"]) || -999);
    const spikePhase = Math.max(0, Math.min(1, spikeAge / 10)); // 0 wind-up, 1 follow-through
    const feintAge = frameCount - ((this.lastHitFrame && this.lastHitFrame["feint"]) || -999);
    const feintPhase = Math.max(0, Math.min(1, feintAge / 10));

    // Simple aim toward ball for front arm (spike/feint/jump)
    const aimAtBall = () => {
      const bx = ball.x;
      const by = ball.y;
      const ax = headX;
      const ay = headY;
      const ang = Math.atan2(by - ay, bx - ax);
      return mirror(ang);
    };
    const platformOffset = 0; // hands meet for platform

    // Arms angles
    let frontArmAng, backArmAng, frontArmBend = 0.35, backArmBend = 0.35;
    if (isWinner) {
      frontArmAng = mirror(-1.2);
      backArmAng = mirror(-1.6);
      frontArmBend = backArmBend = 0.5;
    } else if (isLoser) {
      frontArmAng = mirror(1.4);
      backArmAng = mirror(1.6);
      frontArmBend = backArmBend = 0.25;
    } else if (diving) {
      frontArmAng = this.diveDir > 0 ? 0.05 : Math.PI - 0.05;
      backArmAng = frontArmAng;
      frontArmBend = backArmBend = 0.1;
    } else if (spikePose) {
      // Front arm aims at ball; back arm full wind-up behind head
      const aim = aimAtBall();
      const backWindUp = mirror(-2.7); // overhead, behind head
      const backContact = mirror(0.35);
      frontArmAng = aim;
      backArmAng = lerp(backWindUp, backContact, spikePhase);
      frontArmBend = lerp(0.6, 0.22, spikePhase);
      backArmBend = lerp(0.75, 0.28, spikePhase); // more exaggerated back arm
    } else if (setPose) {
      // Hands above with bent elbows
      frontArmAng = mirror(-1.35);
      backArmAng = mirror(-1.1);
      frontArmBend = backArmBend = 0.75;
    } else if (feintPose) {
      // Front arm aims softly toward ball; back arm cocks then follows
      const aim = aimAtBall();
      const backStart = mirror(-2.0); // overhead cock
      const backEnd = mirror(0.6);    // push forward, not a swing
      frontArmAng = aim;
      backArmAng = lerp(backStart, backEnd, feintPhase);
      frontArmBend = lerp(0.35, 0.22, feintPhase);
      backArmBend = lerp(0.48, 0.3, feintPhase);
    } else if (receivePose || (diving && grounded)) {
      // Platform: forearms meet; on dive keep low bend
      const platformAng = mirror(0.28);
      frontArmAng = platformAng;
      backArmAng = platformAng + platformOffset;
      frontArmBend = backArmBend = diving ? 0.08 : 0.05;
    } else if (jumping) {
      // Ready-to-spike air pose: front arm aims, back arm held overhead
      const aim = aimAtBall();
      frontArmAng = aim;
      backArmAng = mirror(-2.4);
      frontArmBend = 0.5;
      backArmBend = 0.6;
    } else if (falling) {
      frontArmAng = mirror(-0.2);
      backArmAng = mirror(0.8);
      frontArmBend = backArmBend = 0.28;
    } else if (moving && grounded) {
      // Exaggerated counter-swing front/back (front arm leads toward net)
      frontArmAng = mirror(0.2 - runCycle * 0.9);
      backArmAng = mirror(1.6 + runCycle * 0.9);
      frontArmBend = backArmBend = 0.28;
    } else {
      frontArmAng = mirror(0.35);
      backArmAng = mirror(0.9);
      frontArmBend = backArmBend = 0.25;
    }

    // Legs angles
    let frontLegAng, backLegAng, frontLegBend = 0.4, backLegBend = 0.4;
    if (isWinner) {
      const bounce = Math.sin(frameCount * 0.3) * 0.1;
      frontLegAng = mirror(1.0 + bounce);
      backLegAng = mirror(1.0 - bounce);
      frontLegBend = backLegBend = 0.45;
    } else if (isLoser) {
      frontLegAng = mirror(1.55);
      backLegAng = mirror(1.6);
      frontLegBend = backLegBend = 0.35;
    } else if (diving) {
      frontLegAng = mirror(1.3);
      backLegAng = mirror(1.45);
      frontLegBend = backLegBend = 0.25;
    } else if (spikePose) {
      // Trail legs backward relative to facing
      frontLegAng = mirror(1.05);
      backLegAng = mirror(1.75);
      frontLegBend = 0.35;
      backLegBend = 0.55;
    } else if (setPose) {
      frontLegAng = mirror(1.2);
      backLegAng = mirror(1.25);
      frontLegBend = backLegBend = 0.4;
    } else if (feintPose || receivePose) {
      frontLegAng = mirror(1.35);
      backLegAng = mirror(1.65);
      frontLegBend = backLegBend = 0.32;
    } else if (jumping) {
      frontLegAng = mirror(0.95);
      backLegAng = mirror(1.6);
      frontLegBend = 0.35;
      backLegBend = 0.5;
    } else if (falling) {
      frontLegAng = mirror(1.35);
      backLegAng = mirror(1.6);
      frontLegBend = backLegBend = 0.28;
    } else if (moving && grounded) {
      frontLegAng = mirror(1.2 - runCycle * 0.35);
      backLegAng = mirror(1.2 + runCycle * 0.35);
      frontLegBend = backLegBend = 0.35;
    } else {
      // Neutral stance: legs mostly vertical
      frontLegAng = mirror(1.55);
      backLegAng = mirror(1.62);
      frontLegBend = backLegBend = 0.3;
    }

    const leftShoulder = { x: this.x + 10, y: this.y + 38 };
    const rightShoulder = { x: this.x + this.w - 10, y: this.y + 38 };
    const leftHip = { x: this.x + 12, y: this.y + this.h - 6 };
    const rightHip = { x: this.x + this.w - 12, y: this.y + this.h - 6 };
    const upperArm = 17;
    const lowerArm = 12;
    const thighLen = 17;
    const shinLen = 14;

    const frontHip = sideDir > 0 ? rightHip : leftHip;
    const backHip = sideDir > 0 ? leftHip : rightHip;

    // Precompute front/back shoulder order by side (front is toward net)
    const frontShoulder = sideDir > 0 ? rightShoulder : leftShoulder;
    const backShoulder = sideDir > 0 ? leftShoulder : rightShoulder;

    const frontArm = limbChain(frontShoulder.x, frontShoulder.y, frontArmAng, frontArmBend, upperArm, lowerArm);
    const backArm = limbChain(backShoulder.x, backShoulder.y, backArmAng, backArmBend, upperArm, lowerArm);
    const frontLeg = limbChain(frontHip.x, frontHip.y, frontLegAng, frontLegBend, thighLen, shinLen);
    const backLeg = limbChain(backHip.x, backHip.y, backLegAng, backLegBend, thighLen, shinLen);

    // Draw legs and arms using helper function
    const legs = [
      { start: frontHip, joint: frontLeg.knee, end: frontLeg.foot },
      { start: backHip, joint: backLeg.knee, end: backLeg.foot }
    ];
    const arms = [
      { start: frontShoulder, joint: frontArm.knee, end: frontArm.foot },
      { start: backShoulder, joint: backArm.knee, end: backArm.foot }
    ];
    
    drawLimbs(legs, this.color);
    drawLimbs(arms, this.color);

    ctx.restore();
  }
}

// ================== Helper Functions ==================
/**
 * Draw multiple limbs at once with shadow effect
 * @param {array} limbs - Array of limb data [{start, joint, end}, ...]
 * @param {string} color - Color for all limbs
 */
function drawLimbs(limbs, color) {
  // Draw all shadows first
  ctx.strokeStyle = "rgba(0,0,0,0.35)";
  ctx.lineWidth = 5;
  ctx.beginPath();
  for (const limb of limbs) {
    ctx.moveTo(limb.start.x, limb.start.y);
    ctx.lineTo(limb.joint.x, limb.joint.y);
    ctx.moveTo(limb.joint.x, limb.joint.y);
    ctx.lineTo(limb.end.x, limb.end.y);
  }
  ctx.stroke();
  
  // Draw all colored limbs
  ctx.strokeStyle = color;
  ctx.lineWidth = 3;
  ctx.beginPath();
  for (const limb of limbs) {
    ctx.moveTo(limb.start.x, limb.start.y);
    ctx.lineTo(limb.joint.x, limb.joint.y);
    ctx.moveTo(limb.joint.x, limb.joint.y);
    ctx.lineTo(limb.end.x, limb.end.y);
  }
  ctx.stroke();
}

// ================== Ball Class (FIXED SPIKE + FEINTS) ==================
class Ball {
  constructor() {
    this.spin = 0;
    this.spinAngle = 0;
    this.superArmorUntilFrame = -1;
    this.lastInteractFrame = -999;
    this.spikeCharge = { left: 0, right: 0 };
  this.reset();
this.hitUsed = {
    left: { receive: false, set: false, spike: false },
    right: { receive: false, set: false, spike: false }
};

  }



  reset() {
    const dir = serveFromLeft ? 1 : -1;
    // Serve variety: slight random angle/height per rally
    const angleJitter = (Math.random() * 0.4 - 0.2); // -0.2..0.2 radians approx small
    const baseSpeed = 3.1 + Math.random() * 0.8; // 3.1 - 3.9
    const baseVy = -8 + (Math.random() * 1.6 - 0.8); // -8.8..-7.2

    this.x = serveFromLeft ? 150 : 750;
    this.y = 170 + Math.random() * 14 - 7; // slight toss height variance

    const cosA = Math.cos(angleJitter);
    const sinA = Math.sin(angleJitter);
    this.vx = dir * baseSpeed * cosA;
    this.vy = baseVy - Math.abs(baseSpeed * sinA) * 0.4;

    // Initialize previous position for swept collisions
    this.prevX = this.x;
    this.prevY = this.y;

    this.r = 15;
    this.leftTouches = 0;
    this.rightTouches = 0;
    this.lastTouchedSide = null;
    this.spin = 0;
    this.spinAngle = 0;
    this.superArmorUntilFrame = -1;
    this.lastInteractFrame = -999;
    this.rallyHits = 0; // counts successful contacts this rally for speed ramp
  this.hitState = null; // clear hit memory to avoid stale anti-hit after points

    // New serve reaction delay for bot on serve receive
    botServeDelayFrames = 2 + Math.floor(Math.random() * 3); // 2-4 frames

    serveFromLeft = !serveFromLeft;
  }

  update() {
    // Store previous position for swept collisions (net)
    this.prevX = this.x;
    this.prevY = this.y;

    this.vy += gravity;

    this.x += this.vx;
    this.y += this.vy;

    this.vx *= 0.995;
    this.vy *= 0.995;

    // --- Ceiling cushion (soft stop) ---
    const ceiling = this.r;
    if (this.y < ceiling) {
      this.y = ceiling;
      this.vy = Math.max(this.vy, 0);
      this.vx *= 0.97;
      this.spin *= 0.8;
    }

    // --- Extra slow zone near top to give more hang time ---
    if (this.y < 60) {
      this.vy *= 0.9;
      this.vx *= 0.995;
    } else if (this.y < 150 && this.vy > 0) {
      this.vy *= 0.96;
    }

    // --- Tame extreme downward speed so hits aren‚Äôt a 1-frame window ---
    if (this.vy > 11) {
      this.vy *= 0.982;
    }

    const rallyBoost = 1 + Math.min(0.25, (this.rallyHits || 0) * 0.012);
    const maxSpeed = 16 * rallyBoost;
    const speed = Math.hypot(this.vx, this.vy);
    if (speed > maxSpeed) {
      const s = maxSpeed / speed;
      this.vx *= s;
      this.vy *= s;
    }

    // trailing glow following the ball motion
    spawnTrail(this.x, this.y, this.vx, this.vy);

    const wallBounce = 0.7;
    if (this.x < this.r) {
      this.x = this.r;
      this.vx *= -wallBounce;
    }
    if (this.x > canvas.width - this.r) {
      this.x = canvas.width - this.r;
      this.vx *= -wallBounce;
    }

    // =========================
    // NET COLLISION (SWEPT + TOP TAPE)
    // Prevents tunneling through net
    // =========================

    // Detect crossing between previous and current X
    const crossedFromLeft = (this.prevX + this.r <= netLeft) && (this.x + this.r >= netLeft);
    const crossedFromRight = (this.prevX - this.r >= netRight) && (this.x - this.r <= netRight);
    const withinNetHeight = this.y + this.r > netTop && this.y - this.r < netBottom;
    const crossedBottom = (this.prevY - this.r <= netBottom) && (this.y - this.r >= netBottom) && (this.x + this.r > netLeft && this.x - this.r < netRight);

    if (crossedBottom && this.vy > 0) {
      // Hit the bottom of the net: push back up and dampen
      this.y = netBottom - this.r;
      this.vy = -Math.max(2.5, Math.abs(this.vy) * 0.5);
      this.vx *= 0.9;
      spawnBurst(this.x, netBottom - 6, { color: "rgba(255,255,255,0.6)", count: 8, spread: 1.2, speed: 2.4, gravity: 0.18, size: 3 });
      playSound("net");
    } else if (withinNetHeight && (crossedFromLeft || crossedFromRight)) {
      // Position ball flush against the net and reflect
      if (crossedFromLeft) {
        this.x = netLeft - this.r;
      } else {
        this.x = netRight + this.r;
      }
      this.vx = -Math.sign(this.vx || (crossedFromLeft ? 1 : -1)) * Math.max(2.2, Math.abs(this.vx) * 0.65);
      this.vy *= 0.92;
      spawnBurst(this.x, this.y, { color: "rgba(255,255,255,0.55)", count: 10, spread: 1.5, speed: 2.8, gravity: 0.2, size: 3 });
      playSound("net");
    } else {
      // Top tape collision
      if (this.y + this.r > netTop - 5 && this.y - this.r < netTop + 5 && this.x + this.r > netLeft && this.x - this.r < netRight) {
        this.y = netTop - this.r;
        const lastSide = this.lastTouchedSide;
        const sidePush = lastSide === "left" ? 1 : (lastSide === "right" ? -1 : (this.x < 450 ? -1 : 1));
        const minBounce = 3.4;
        const boostedVy = Math.abs(this.vy) < 2.2 ? 2.2 : Math.abs(this.vy);
        // Stronger upward + definite lateral push off the tape so it can't linger on the net
        this.vy = -Math.max(minBounce, boostedVy * 0.65);
        const baseSide = Math.max(0.8, Math.abs(this.vx));
        this.vx = baseSide * sidePush * 0.92;
        if (Math.abs(this.vx) < 0.8) this.vx = 0.8 * sidePush;
        // Keep touch attribution when netting
        this.lastTouchedSide = lastSide;
        spawnBurst(this.x, netTop - 4, { color: "rgba(255,255,255,0.7)", count: 9, spread: 1.3, speed: 2.5, gravity: 0.15, size: 3 });
        playSound("net");
      }

      // Static side overlap fallback
      if (withinNetHeight) {
        if (this.x + this.r > netLeft && this.x < netLeft) {
          this.x = netLeft - this.r;
          this.vx = -Math.abs(this.vx) * 0.7;
        } else if (this.x - this.r < netRight && this.x > netRight) {
          this.x = netRight + this.r;
          this.vx = Math.abs(this.vx) * 0.7;
        }
      }
    }

    if (this.y > 430) {
      if (this.x < 450) p2.score++;
      else p1.score++;

      playSound("score");
      resetPositions();
      this.reset();
    }

    this.spin *= 0.99;
    // Integrate spin for visual rotation; add a subtle auto-spin from ball velocity
    const autoSpin = Math.sign(this.vx || 1) * (Math.abs(this.vx) + Math.abs(this.vy)) * 0.003;
    this.spinAngle += this.spin + autoSpin;
    if (this.spinAngle > Math.PI * 2 || this.spinAngle < -Math.PI * 2) {
      this.spinAngle %= Math.PI * 2;
    }
  }

  static randRange(min, max) {
    return min + Math.random() * (max - min);
  }

  _addCharge(side, touches, actionType) {
    const key = side === "left" ? "left" : "right";
    if (!this.spikeCharge) this.spikeCharge = { left: 0, right: 0 };
    const chargeThreshold = 28;
    const current = this.spikeCharge[key] || 0;

    if (actionType === "spike" && current >= chargeThreshold) {
      this.spikeCharge[key] = 0;
      return;
    }

    let gain = 0.8;
    if (actionType === "set") {
      gain = 1.4 + (touches === 1 ? 0.2 : 0);
    } else if (actionType === "spike") {
      gain = 2.4 + (touches === 2 ? 0.6 : 0);
    } else if (actionType === "dive") {
      gain = 1.1;
    } else if (actionType === "feint") {
      gain = 1.2;
    }

    this.spikeCharge[key] = Math.min(chargeThreshold, current + gain);
  }

  _updateNetCampingTracking(player, inNetBand) {
    if (inNetBand) {
      if (frameCount - player.netInteractWindowStart > 60) {
        player.netInteractWindowStart = frameCount;
        player.netInteractCount = 0;
      }
      player.netInteractCount += 1;
      if (player.netInteractCount >= 3) {
        const extra = player.netInteractCount - 3;
        player.netInteractCooldown = Math.min(24, 6 + extra * 4);
      }
    } else {
      player.netInteractCount = 0;
      player.netInteractWindowStart = frameCount;
    }
  }

  _calculateHitbox(player, type, extraHitbox) {
    const grounded = player.isGrounded();

    let baseX = player.x - 5;
    let baseW = player.w + 10;
    let baseY = player.y - 2;
    let baseH = player.h + 17;

    if (player.diveTimer > 0) {
      baseY += 14;
      baseH *= 0.42;
      baseW *= 1.25;
    }

    const px = baseX + baseW / 2;
    const py = baseY + baseH / 2;

    let airRadius = type === "receive" ? 80 : 64;
    if (type === "receive") {
      if (player.isBot) {
        airRadius *= 1.2;
      } else {
        airRadius *= 0.85;
      }
    }

    if (player.diveTimer > 0) {
      airRadius *= 1.25;
    }

    if (this.vy > 5.5) {
      airRadius *= 1.3;
    }
    if (this.vy > 8.5) {
      airRadius *= 1.1;
    }
    const airHit = distance(this.x, this.y, px, py) < airRadius;

    let padX = 12.5 + extraHitbox;
    let padY = 18 + extraHitbox;

    if (player.diveTimer > 0) {
      padX *= 1.25;
      padY *= 0.5;
    }

    if (type === "receive") {
      const rxScale = player.isBot ? 1.1 : 1.02;
      const ryScale = player.isBot ? 1.1 : 1.02;
      padX *= rxScale;
      padY *= ryScale;

      if (this.vy > 5.5) {
        padX *= 1.2;
        padY *= 1.2;
      }
      if (this.vy > 8.5) {
        padX *= 1.12;
        padY *= 1.12;
        airRadius += 10;
      }
    }

    if (!player.isBot) {
      const receiveScaleX = 0.60;
      const receiveScaleY = 0.72;
      const generalScaleX = 0.62;
      const generalScaleY = 0.68;
      const useReceive = (type === "receive");
      padX *= useReceive ? receiveScaleX : generalScaleX;
      padY *= useReceive ? receiveScaleY : generalScaleY;
    } else {
      padX *= 1.2;
      padY *= 1.2;

      if (type === "spike") {
        padX *= 1.6;
        padY *= 1.3;
      }
    }

    const highBall = this.y < 230;
    if (!grounded && highBall) {
      if (player.isBot) {
        padX *= 1.3;
        padY *= 1.28;
      } else {
        padX *= 1.08;
        padY *= 1.08;
      }
      airRadius += 14;
    }

    if (grounded && highBall) {
      if (player.isBot) {
        padX *= 1.32;
        padY *= 1.28;
      } else {
        padX *= 1.08;
        padY *= 1.06;
      }
      airRadius += 12;
    }

    const rectHit =
      this.x + this.r > baseX - padX &&
      this.x - this.r < baseX + baseW + padX &&
      this.y + this.r > baseY - padY &&
      this.y - this.r < baseY + baseH + padY;

    let hit = grounded ? (rectHit || (highBall && airHit)) : (rectHit || airHit);

    if (!hit) {
      const rx0 = baseX - padX;
      const rx1 = baseX + baseW + padX;
      const ry0 = baseY - padY;
      const ry1 = baseY + baseH + padY;

      const segMinX = Math.min(this.prevX, this.x) - this.r;
      const segMaxX = Math.max(this.prevX, this.x) + this.r;
      const segMinY = Math.min(this.prevY, this.y) - this.r;
      const segMaxY = Math.max(this.prevY, this.y) + this.r;

      if (segMaxX > rx0 && segMinX < rx1 && segMaxY > ry0 && segMinY < ry1) {
        hit = true;
      }
    }

    return { hit, airHit, rectHit, baseX, baseW, baseY, baseH, padX, padY };
  }

  _checkAntiDoubleHit(player, type, state, baseX, baseW, baseY, baseH, padX, padY) {
    const grounded = player.isGrounded();
    const highBall = this.y < 230;

    let antiPadX = padX * 0.6;
    let antiPadY = padY * 0.6;

    if (player.isBot) {
      antiPadX *= 0.9;
      antiPadY *= 0.9;
    }

    if (this.vy > 5.5) {
      antiPadX *= 0.97;
      antiPadY *= 0.97;
    }
    if (this.vy > 8.5) {
      antiPadX *= 0.99;
      antiPadY *= 0.99;
    }
    if (grounded && highBall && !player.isBot) {
      antiPadX *= 1.04;
      antiPadY *= 1.04;
    }

    const antiHit =
      this.x + this.r > baseX - antiPadX &&
      this.x - this.r < baseX + baseW + antiPadX &&
      this.y + this.r > baseY - antiPadY &&
      this.y - this.r < baseY + baseH + antiPadY;

    if (!antiHit) {
      state.inside = false;
      state.lastType = null;
      return false;
    }

    const now = frameCount;
    const frameDelay = player.isBot ? 10 : 9;

    if (
      state.inside &&
      state.lastType === type &&
      now - state.lastFrame < frameDelay
    ) {
      return false;
    }

    return true;
  }

  _registerHit(state, side, type) {
    const now = frameCount;
    state.inside = true;
    state.lastType = type;
    state.lastFrame = now;

    const otherSide = side === "left" ? "right" : "left";
    if (this.hitState[otherSide]) {
      this.hitState[otherSide].inside = false;
      this.hitState[otherSide].lastType = null;
      this.hitState[otherSide].lastFrame = -999;
    }

    const prevSide = this.lastTouchedSide;
    if (prevSide && prevSide !== side) {
      if (side === "left") this.rightTouches = 0;
      else this.leftTouches = 0;

      this.lastTouchType = null;
      this.setBuffUntilFrame = -1;
    }
  }

  _applyFeint(player, type, grounded, dir, addCharge) {
    if (type === "receive" && !grounded) {
      this.vx *= 0.75;
      this.vy *= 0.75;

      this.vx += dir * 4;

      if (this.y > 300) {
        this.vy = -14;
      } else if (this.y > 260) {
        this.vy = -10;
      } else {
        this.vy = -6;
      }

      this.spin += dir * 0.35;
      this.vy += 1.0;

      const netX = player.side === "left" ? 445 : 455;
      const t = (netX - this.x) / this.vx;

      if (t > 0 && t < 1.2) {
        const predictedY = this.y + this.vy * t + 0.5 * gravity * t * t;

        if (predictedY > 250) {
          this.vy -= (predictedY - 250) * 0.7;
        }
      }

      spawnBurst(this.x, this.y, { color: "rgba(130,200,255,0.7)", count: 12, spread: 1.5, speed: 2.9, gravity: 0.22, size: 3 });
      playSound("feint");

      addCharge("feint");

      if (player.side === "left") this.leftTouches++;
      else this.rightTouches++;

      this.lastTouchedSide = player.side;
      player.lastHitFrame[type] = frameCount;
      player.lastHitFrame["feint"] = frameCount;
      return true;
    }
    return false;
  }

  _applyThirdHitReceiveSet(player, type, isThirdHit, dir, addCharge) {
    if (isThirdHit && (type === "receive" || type === "set")) {
      const netX = 450;
      const netDist = Math.abs(this.x - netX);
      const farFactor = Math.max(0, Math.min(1, (netDist - 110) / 200));

      const fastFallBoost = this.vy > 5 ? 0.6 : 0;
      this.vx = dir * (3.8 + 2.2 * farFactor + fastFallBoost);
      this.vy = -14.8 - 4.2 * farFactor - (this.vy > 5 ? 1.2 : 0);
      if (farFactor > 0.55) {
        this.vx += dir * 1.2;
      }
      this.vx = Math.max(-8.4, Math.min(8.4, this.vx));

      const t = (netX - this.x) / this.vx;
      if (t > 0 && t < 1.6) {
        const predictedY = this.y + this.vy * t + 0.5 * gravity * t * t;
        if (predictedY > 248) {
          this.vy -= (predictedY - 248) * 0.8;
        }
      }

      this.spin += dir * 0.22;
      spawnBurst(this.x, this.y, { color: "rgba(255, 226, 150, 0.75)", count: 12, spread: 1.7, speed: 3.2, gravity: 0.25, size: 4 });
      playSound("set");

      this.lastTouchType = "set";
      this.setBuffUntilFrame = frameCount + 70;

      addCharge("set");

      if (player.side === "left") this.leftTouches++;
      else this.rightTouches++;

      this.lastTouchedSide = player.side;
      player.lastHitFrame[type] = frameCount;
      return true;
    }
    return false;
  }

  _applyReceive(player, type, grounded, dir, addCharge) {
    if (type === "receive") {
      if (player.diveTimer > 0) {
        const netX = player.side === "left" ? 445 : 455;
        const netDist = Math.abs(this.x - netX);
        const farFactor = Math.max(0, Math.min(1, (netDist - 90) / 220));
        this.vy = -12.5 - 3.2 * farFactor;
        this.vx = (player.side === "left" ? 1 : -1) * (7.2 + 2.2 * farFactor);

        const t = (netX - this.x) / this.vx;
        if (t > 0 && t < 1.6) {
          const predictedY = this.y + this.vy * t + 0.5 * gravity * t * t;
          if (predictedY > 248) {
            this.vy -= (predictedY - 248) * 0.8;
          }
        }

        addCharge("dive");
      } else {
        this.vy = -8;
        this.vx = dir * 1.5;
        addCharge("receive");
      }
      this.spin += dir * 0.12;
      spawnBurst(this.x, this.y, { color: "rgba(120,200,255,0.7)", count: 10, spread: 1.6, speed: 2.8, gravity: 0.25, size: 3 });
      playSound("receive");

      if (player.side === "left") this.leftTouches++;
      else this.rightTouches++;

      this.lastTouchedSide = player.side;
      this.lastInteractFrame = frameCount;
      player.lastHitFrame[type] = frameCount;
      return true;
    }
    return false;
  }

  _applySet(player, type, touches, dir, addCharge) {
    if (type === "set") {
      this.vy = -12.0;
      this.vx = dir * 0.3;
      this.spin += dir * 0.20;

      const aimBias = Math.max(-1, Math.min(1, (player.vx || 0) / 2.2));
      const steer = aimBias * 1.55;
      this.vx += steer;

      const isThirdHit = touches === 2;
      const maxVX = isThirdHit ? 6.8 : 4.2;
      this.vx = Math.max(-maxVX, Math.min(maxVX, this.vx));

      if (!isThirdHit) {
        const towardNet = dir;
        if (Math.sign(this.vx || 0) === towardNet) {
          this.vx = Math.min(Math.abs(this.vx), 3.0) * towardNet;
        }
      }

      if (player.isBot) {
        this.vy = Math.max(this.vy, -9.0);
        this.vx *= 0.78;
      }

      this.lastTouchType = "set";
      this.setBuffUntilFrame = frameCount + 70;

      spawnBurst(this.x, this.y, { color: "rgba(160, 230, 255, 0.75)", count: 10, spread: 1.5, speed: 3.0, gravity: 0.22, size: 3 });
      playSound("set");

      addCharge("set");
      return true;
    }
    return false;
  }

  _applySpike(player, type, sprinting, touches, isThirdHit, dir, addCharge) {
    if (type === "spike") {
      const sideKey = player.side === "left" ? "left" : "right";
      const chargeCount = (this.spikeCharge && this.spikeCharge[sideKey]) || 0;
      const chargeThreshold = 28;
      const isSuperSpike = chargeCount >= chargeThreshold;

      this.vx *= 0.3;
      this.vy *= 0.3;

      const netX = 450;
      const netDist = Math.abs(this.x - netX);
      const netFactor = Math.min(1, netDist / 260);

      let targetX = player.side === "left"
        ? Ball.randRange(500, 650)
        : Ball.randRange(250, 400);

      let targetY;

      if (this.y > 300) {
        targetY = 140;
      } else if (this.y > 260) {
        targetY = 165;
      } else {
        targetY = 188;
      }

      if (player.isBot) targetY -= 22;

      targetY += netFactor * 48;

      if (netDist < 60) {
        targetY += 32;
      }

      if (netDist > 160) targetY -= 20;
      if (netDist > 200) targetY -= 18;
      if (player.isBot && netDist < 90) targetY -= 8;

      let dx = targetX - this.x;
      let dy = targetY - this.y;

      if (Math.abs(dx) < 0.01 && Math.abs(dy) < 0.01) {
        dx = dir * 1;
        dy = -1;
      }

      let dist = Math.max(1, Math.hypot(dx, dy));
      let nx = dx / dist;
      let ny = dy / dist;

      ny -= netFactor * 0.24;

      if (netDist < 60) {
        ny -= 0.08;
      }

      const mag = Math.hypot(nx, ny);
      nx /= mag;
      ny /= mag;

      let spikePower = isThirdHit ? 14 : 12;

      if (sprinting && !player.isBot) {
        spikePower *= 1.18;
      }

      if (isSuperSpike) {
        spikePower *= 1.55;
      }

      const mvx = player.vx || 0;
      const mvy = player.vy || 0;

      spikePower += Math.abs(mvx) * 0.4;
      spikePower += Math.max(0, -mvy) * (player.isBot ? 0.5 : 0.3);

      spikePower += netFactor * 2.0;

      spikePower *= Math.min(1.05, dist / 180);
      if (player.isBot) spikePower *= 1.08;
      spikePower = Math.min(spikePower, player.isBot ? 17.0 : 15.5);

      const setBuffActive = this.lastTouchType === "set" && frameCount <= (this.setBuffUntilFrame || -1);
      let vx = nx * spikePower;
      let vy = ny * spikePower;

      if (sprinting && !player.isBot) {
        vx *= 1.06;
        vy *= 1.04;
      }

      if (setBuffActive) {
        vx *= 1.3;
        vy *= 1.15;
        vy *= 0.9;
        if (player.isBot) {
          vx *= 1.08;
          vy *= 1.08;
        }
      }

      if (player.isBot && Math.abs(this.x - netX) < 110) {
        vy -= 0.9;
        vx *= 0.97;
      }

      if (isSuperSpike) {
        vx *= 1.15;
        vy *= 1.15;
        this.superArmorUntilFrame = frameCount + 45;
      } else {
        this.superArmorUntilFrame = -1;
      }

      if (player.isBot) {
        const nearNet = Math.abs(this.x - netX) < 70;
        if (nearNet) {
          vy -= 3.6;
          vx *= 0.9;
        }
      }

      const netX1 = 445;
      const netX2 = 455;
      const netTop = 260;
      const clearance = player.isBot ? 36 : 12;

      const targetNetX = player.side === "left" ? netX1 : netX2;
      const t = (targetNetX - this.x) / vx;

      if (t > 0 && t < 1.2) {
        const predictedY = this.y + vy * t + 0.5 * gravity * t * t;

        if (predictedY > netTop - clearance) {
          const neededLift = (predictedY - (netTop - clearance)) * (player.isBot ? 1.32 : 1.1);
          vy -= neededLift;

          vx *= player.isBot ? 0.8 : 0.94;

          const newSpeed = Math.hypot(vx, vy);
          if (newSpeed > 15.5) {
            const s = 15.5 / newSpeed;
            vx *= s;
            vy *= s;
          }
        }
      }

      this.vx = vx;
      this.vy = vy;

      this.spin += dir * (isSuperSpike ? 0.8 : 0.45);
      cameraShake = settings.screenShake ? (isSuperSpike ? 14 : (isThirdHit ? 10 : 7)) : 0;
      spawnBurst(this.x, this.y, { color: isSuperSpike ? "rgba(255,60,200,0.95)" : "rgba(255,140,105,0.8)", count: isSuperSpike ? 32 : 16, spread: isSuperSpike ? 2.4 : 2.0, speed: isSuperSpike ? 6.0 : 4.2, gravity: 0.28, size: isSuperSpike ? 6 : 4 });
      if (isSuperSpike) {
        spawnBurst(this.x, this.y - 20, { color: "rgba(120,200,255,0.7)", count: 18, spread: 1.6, speed: 4.5, gravity: 0.2, size: 4 });
      }
      const spikeSpeed = Math.hypot(this.vx, this.vy);
      if (spikeSpeed > 13) {
        playSound("whoosh", { intensity: Math.min(1.25, spikeSpeed / 16) });
      }
      playSound(isSuperSpike ? "superSpike" : "spike", { intensity: isSuperSpike ? 1.35 : 1 });

      addCharge("spike");
      return true;
    }
    return false;
  }

  _finalBookkeeping(player, type) {
    if (player.side === "left") this.leftTouches++;
    else this.rightTouches++;

    this.lastTouchedSide = player.side;
    this.lastInteractFrame = frameCount;
    player.lastHitFrame[type] = frameCount;

    this.rallyHits = (this.rallyHits || 0) + 1;
    const rallyBoost = 1 + Math.min(0.25, this.rallyHits * 0.012);
    this.vx *= rallyBoost;
    this.vy *= rallyBoost;
  }

  _initializeHitState() {
    if (!this.hitState) {
      this.hitState = {
        left: { lastType: null, lastFrame: -999, inside: false },
        right:{ lastType: null, lastFrame: -999, inside: false }
      };
    }
  }

  _canInteract(player) {
    if (frameCount - this.lastInteractFrame < 2) return false;
    if (frameCount <= this.superArmorUntilFrame && this.lastTouchedSide && player.side !== this.lastTouchedSide) return false;
    if (player.side === "left" && this.x > netRight) return false;
    if (player.side === "right" && this.x < netLeft) return false;
    if (this.x > netLeft - 2 && this.x < netRight + 2) return false;
    
    const nearNetBand = 26;
    const inNetBand = player.side === "left"
      ? (player.x + player.w) > netLeft - nearNetBand
      : player.x < netRight + nearNetBand;
    if (inNetBand && player.netInteractCooldown > 0) return false;
    
    const touches = player.side === "left" ? this.leftTouches : this.rightTouches;
    if (touches >= 3) return false;
    
    return true;
  }

  _getNetBandInfo(player) {
    const nearNetBand = 26;
    const inNetBand = player.side === "left"
      ? (player.x + player.w) > netLeft - nearNetBand
      : player.x < netRight + nearNetBand;
    return { nearNetBand, inNetBand };
  }

  interact(player, type, extraHitbox = 0) {
    const sprinting = !!player.sprinting;
    this._initializeHitState();

    if (!this._canInteract(player)) return;

    const side = player.side;
    const state = this.hitState[side];
    const touches = side === "left" ? this.leftTouches : this.rightTouches;
    const { inNetBand } = this._getNetBandInfo(player);

    const addCharge = (actionType) => this._addCharge(side, touches, actionType);

    this._updateNetCampingTracking(player, inNetBand);

    const { hit, airHit, rectHit, baseX, baseW, baseY, baseH, padX, padY } = this._calculateHitbox(player, type, extraHitbox);

    if (!this._checkAntiDoubleHit(player, type, state, baseX, baseW, baseY, baseH, padX, padY)) return;

    if (!hit) return;

    this._registerHit(state, side, type);

    this.vx *= 0.35;
    this.vy *= 0.35;

    const dir = player.side === "left" ? 1 : -1;
    const isThirdHit = touches === 2;
    const grounded = player.isGrounded();

    if (this._applyFeint(player, type, grounded, dir, addCharge)) return;
    if (this._applyThirdHitReceiveSet(player, type, isThirdHit, dir, addCharge)) return;
    if (this._applyReceive(player, type, grounded, dir, addCharge)) return;
    
    // Set and spike check type internally; only one will execute per interaction
    // Whichever executes continues to final bookkeeping (no early return)
    if (!this._applySet(player, type, touches, dir, addCharge)) {
      this._applySpike(player, type, sprinting, touches, isThirdHit, dir, addCharge);
    }

    this._finalBookkeeping(player, type);

  }
  draw() {
    // Use 3D renderer if enabled
    if (renderer3D.enabled) {
      // Draw 3D ball with size modifier from power-ups
      const sizeMultiplier = shopItems.find(i => i.id === "giantBall")?.active ? 1.5 : 1;
      draw3DSphere(this.x, this.y, 20, this.r * sizeMultiplier, '#eaf1ff');
      return;
    }
    
    ctx.save();
    // soft ground shadow
    const shadowScale = Math.max(0.35, Math.min(1, 1 - (this.y - 80) / 320));
    const shadowX = this.x;
    const shadowY = groundY + 104; // align with player shadow plane
    ctx.save();
    ctx.globalAlpha = 0.35 * shadowScale;
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.beginPath();
    ctx.ellipse(shadowX, shadowY, this.r * 1.4 * shadowScale, this.r * 0.55 * shadowScale, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.translate(this.x, this.y);

    const shake = settings.screenShake ? cameraShake : 0;
    if (shake > 0) {
      const shakeX = (Math.random() * 2 - 1) * shake;
      const shakeY = (Math.random() * 2 - 1) * shake;
      ctx.translate(shakeX, shakeY);
      cameraShake *= 0.9;
      if (cameraShake < 0.2) cameraShake = 0;
    }

  ctx.rotate(this.spinAngle);

  // soft glow
  ctx.shadowColor = "rgba(255,255,255,0.5)";
  ctx.shadowBlur = 14;

  // base sphere
  const grad = ctx.createRadialGradient(-6, -8, 2, 0, 0, this.r + 4);
  grad.addColorStop(0, "#ffffff");
  grad.addColorStop(0.5, "#eaf1ff");
  grad.addColorStop(1, "#c7d8ff");
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(0, 0, this.r, 0, Math.PI * 2);
  ctx.fill();

  // panel shading
  ctx.shadowBlur = 0;
  ctx.strokeStyle = "rgba(0,0,0,0.12)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(0, 0, this.r - 2, 0.9, Math.PI + 0.9);
  ctx.stroke();

  // accent bands
  ctx.strokeStyle = "#ffcf4a";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(0, 0, this.r - 3, -0.2, Math.PI - 0.4);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(0, 0, this.r - 5, Math.PI * 0.8, Math.PI * 1.8);
  ctx.stroke();

  // highlight streak
  const gloss = ctx.createRadialGradient(-8, -10, 1, -4, -6, 16);
  gloss.addColorStop(0, "rgba(255,255,255,0.9)");
  gloss.addColorStop(1, "rgba(255,255,255,0)");
  ctx.fillStyle = gloss;
  ctx.beginPath();
  ctx.ellipse(-2, -6, 12, 16, -0.4, 0, Math.PI * 2);
  ctx.fill();

    ctx.restore();
  }
}




// ================== Game Setup ==================
let serveFromLeft = true;
const p1 = new Player(150, "left", false, CONFIG.PLAYER_COLOR);
const p2 = new Player(710, "right", true, CONFIG.CPU_COLOR);

/**
 * Apply bot difficulty settings from CONFIG
 */
function applyBotDifficulty() {
  const mode = settings.botDifficulty;
  const config = CONFIG.BOT_DIFFICULTY[mode] || CONFIG.BOT_DIFFICULTY.normal;
  p2.speed = config.speed;
  p2.jumpPower = config.jumpPower;
}

applyBotDifficulty();
const ball = new Ball();

function drawNet() {
  // Use 3D renderer if enabled
  if (renderer3D.enabled) {
    // 3D Net posts
    draw3DCylinder(443, 250, 15, 4, 190, '#0e2845');
    draw3DCylinder(453, 250, 15, 4, 190, '#0e2845');
    
    // 3D Net body
    draw3DBox(445, 260, 10, 10, 170, 8, '#ffffff');
    return;
  }
  
  ctx.save();
  // Posts
  ctx.shadowColor = "rgba(0,0,0,0.25)";
  ctx.shadowBlur = 8;
  ctx.fillStyle = "#0e2845";
  ctx.fillRect(440, 250, 6, 190);
  ctx.fillRect(454, 250, 6, 190);

  // Padding on posts
  ctx.fillStyle = "#1f4d8b";
  ctx.fillRect(438, 260, 10, 70);
  ctx.fillRect(452, 260, 10, 70);

  // Net body
  ctx.shadowBlur = 0;
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.fillRect(445, 260, 10, 170);

  // Top tape and rope
  const tapeGrad = ctx.createLinearGradient(445, 255, 455, 270);
  tapeGrad.addColorStop(0, "#ffffff");
  tapeGrad.addColorStop(1, "#d7e6ff");
  ctx.fillStyle = tapeGrad;
  ctx.fillRect(445, 252, 10, 10);
  ctx.fillStyle = "rgba(0,0,0,0.18)";
  ctx.fillRect(445, 262, 10, 2);

  // Net pattern
  ctx.strokeStyle = "rgba(255,255,255,0.72)";
  ctx.lineWidth = 1;
  for (let y = 270; y < 430; y += 12) {
    ctx.beginPath();
    ctx.moveTo(445, y);
    ctx.lineTo(455, y);
    ctx.stroke();
  }
  ctx.restore();
}

function drawScoreboard() {
  ctx.save();
  const panelGrad = ctx.createLinearGradient(340, 8, 560, 56);
  panelGrad.addColorStop(0, "rgba(6,18,34,0.9)");
  panelGrad.addColorStop(1, "rgba(18,44,78,0.85)");
  ctx.fillStyle = panelGrad;
  ctx.shadowColor = "rgba(0,0,0,0.35)";
  ctx.shadowBlur = 10;
  ctx.fillRect(330, 10, 240, 54);

  ctx.shadowBlur = 0;
  ctx.strokeStyle = "rgba(255,255,255,0.28)";
  ctx.lineWidth = 1.5;
  ctx.strokeRect(330, 10, 240, 54);

  ctx.fillStyle = "#f7fbff";
  ctx.font = "22px 'Segoe UI', Arial";
  ctx.fillText("P1: " + p1.score, 346, 42);
  ctx.fillText("CPU: " + p2.score, 456, 42);

  ctx.font = "12px 'Segoe UI', Arial";
  ctx.fillStyle = "rgba(255,255,255,0.7)";
  ctx.fillText(`To ${settings.targetScore}`, 450, 58);

  // subtle byline below the scoreboard
  ctx.font = "12px 'Segoe UI', Arial";
  ctx.fillStyle = "rgba(255,255,255,0.55)";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.fillText("By Joshua Oh", 450, 70);

  // Muted tag
  if (masterVolume <= 0) {
    ctx.font = "12px 'Segoe UI', Arial";
    ctx.fillStyle = "rgba(255,255,255,0.7)";
    ctx.fillText("Muted", 450, 74);
  }
  ctx.restore();
}

function drawStaminaBar(player) {
  const isCPU = player.isBot;
  const width = 220;
  const height = 16;
  const padding = 20;
  const x = isCPU ? canvas.width - width - padding : 20;
  const y = canvas.height - height - 6;

  const pct = Math.max(0, Math.min(1, player.stamina / player.maxStamina));

  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.fillRect(x - 2, y - 2, width + 4, height + 4);

  const barGrad = ctx.createLinearGradient(x, y, x + width, y);
  barGrad.addColorStop(0, "#6ee7ff");
  barGrad.addColorStop(1, "#4dd0e1");
  ctx.fillStyle = barGrad;
  ctx.fillRect(x, y, width * pct, height);

  ctx.strokeStyle = "rgba(255,255,255,0.6)";
  ctx.lineWidth = 2;
  ctx.strokeRect(x, y, width, height);

  ctx.fillStyle = "white";
  ctx.font = "12px 'Segoe UI', Arial";
  ctx.fillText(isCPU ? "CPU Stamina" : "Stamina", x, y - 6);
  ctx.restore();
}

function drawSuperCharge(player) {
  const key = player.side === "left" ? "left" : "right";
  const current = (ball.spikeCharge && ball.spikeCharge[key]) || 0;
  const threshold = 28;
  const ready = current >= threshold;
  const pct = Math.max(0, Math.min(1, current / threshold));
  const nearReady = pct >= 0.8;

  const isCPU = player.isBot;
  const width = 200;
  const height = 10;
  const padding = 16;

  const x = isCPU ? canvas.width - width - padding : 20;
  const y = padding;

  ctx.save();

  if (nearReady) {
    ctx.save();
    const glowColor = ready ? "rgba(0,255,180,0.4)" : "rgba(255,120,200,0.25)";
    ctx.fillStyle = glowColor;
    ctx.shadowColor = glowColor;
    ctx.shadowBlur = ready ? 20 : 14;
    ctx.globalAlpha = 0.8;
    ctx.fillRect(x - 8, y - 8, width + 16, height + 16);
    ctx.restore();
  }

  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.fillRect(x - 2, y - 2, width + 4, height + 4);

  const barGrad = ctx.createLinearGradient(x, y, x + width, y);
  barGrad.addColorStop(0, "#ff8ad1");
  barGrad.addColorStop(1, "#ff5c8a");
  ctx.fillStyle = barGrad;
  ctx.fillRect(x, y, width * pct, height);

  ctx.strokeStyle = ready ? "rgba(0,255,180,0.8)" : "rgba(255,255,255,0.6)";
  ctx.lineWidth = ready ? 2 : 1.5;
  ctx.strokeRect(x, y, width, height);

  ctx.fillStyle = ready ? "#9cffc7" : "white";
  ctx.font = "12px 'Segoe UI', Arial";
  ctx.textAlign = "left";
  ctx.textBaseline = "bottom";
  const percent = Math.round(pct * 100);
  const label = ready ? "Super Spike READY" : `Super Spike ${percent}%`;
  ctx.fillText(label, x, y - 2);
  ctx.restore();
}

function drawKeybinds() {
  ctx.save();
  const staminaX = 20;
  const staminaWidth = 220;
  const y = 520 - 42; // align with stamina bar
  const x = staminaX + staminaWidth + 20;

  const text = "Arrows move | Q spike | E set | S receive | B shop | G casino | C chem | K caterpillar | T mode";
  ctx.font = "11px 'Segoe UI', Arial";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";

  // subtle strip behind text to keep readability without blocking view
  const metrics = ctx.measureText(text);
  const h = 16;
  const padX = 6;
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.fillRect(x - padX, y - 2, metrics.width + padX * 2, h + 4);

  ctx.fillStyle = "white";
  ctx.fillText(text, x, y);

  ctx.restore();
}

function drawSky(map) {
  const sky = ctx.createLinearGradient(0, 0, 0, 320);
  sky.addColorStop(0, map.sky[0]);
  sky.addColorStop(0.35, map.sky[1]);
  sky.addColorStop(1, map.sky[2]);
  ctx.fillStyle = sky;
  ctx.fillRect(0, 0, canvas.width, 320);
}

function drawSun(map, isIndoor) {
  const sunX = 140, sunY = 80;
  if (!isIndoor && map.sun.alpha > 0) {
    const sun = ctx.createRadialGradient(sunX, sunY, 14, sunX, sunY, map.sun.radius);
    sun.addColorStop(0, map.sun.main);
    sun.addColorStop(0.45, map.sun.halo);
    sun.addColorStop(1, "rgba(0,0,0,0)");
    ctx.save();
    ctx.globalAlpha = map.sun.alpha;
    ctx.fillStyle = sun;
    ctx.beginPath();
    ctx.arc(sunX, sunY, map.sun.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

function drawLightRays(map, isIndoor) {
  const sunX = 140;
  if (!isIndoor && map.raysAlpha > 0) {
    ctx.save();
    ctx.globalAlpha = map.raysAlpha;
    ctx.fillStyle = map.sun.halo || "#ffdfa4";
    for (let i = 0; i < 5; i++) {
      ctx.beginPath();
      const offset = i * 16;
      ctx.moveTo(sunX - 12 + offset, 0);
      ctx.lineTo(sunX + 160 + offset, 0);
      ctx.lineTo(sunX + 60 + offset, 260);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }
}

function drawClouds(map, isIndoor) {
  if (!isIndoor) {
    ctx.fillStyle = map.cloudColor;
    for (let i = 0; i < 4; i++) {
      const cx = 200 + i * 190;
      const cy = 86 + (i % 2) * 14;
      ctx.beginPath();
      ctx.ellipse(cx, cy, 70, 22, 0, 0, Math.PI * 2);
      ctx.ellipse(cx + 40, cy + 6, 52, 18, 0, 0, Math.PI * 2);
      ctx.ellipse(cx - 44, cy + 10, 48, 16, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

function drawHorizon(map) {
  const horizon = ctx.createLinearGradient(0, 200, 0, 320);
  horizon.addColorStop(0, map.horizon[0]);
  horizon.addColorStop(1, map.horizon[1]);
  ctx.fillStyle = horizon;
  ctx.fillRect(0, 180, canvas.width, 160);
}

function drawWater(map) {
  const water = ctx.createLinearGradient(0, 220, 0, 270);
  water.addColorStop(0, map.water[0]);
  water.addColorStop(1, map.water[1]);
  ctx.fillStyle = water;
  ctx.fillRect(0, 220, canvas.width, 70);
  ctx.fillStyle = "rgba(255,255,255,0.18)";
  for (let i = 0; i < canvas.width; i += 90) {
    ctx.beginPath();
    ctx.ellipse(i + 30, 260 + Math.sin(i * 0.02) * 3, 60, 8, 0, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawCrowd(map) {
  ctx.fillStyle = map.crowdBase;
  ctx.fillRect(0, 240, canvas.width, 44);
  ctx.fillStyle = map.crowdAccent;
  for (let i = 0; i < canvas.width; i += 18) {
    const h = 14 + (i % 3 === 0 ? 4 : 0);
    ctx.fillRect(i, 244, 10, h);
  }
}

function drawSand(map) {
  const sand = ctx.createLinearGradient(0, 260, 0, canvas.height);
  sand.addColorStop(0, map.sand[0]);
  sand.addColorStop(1, map.sand[1]);
  ctx.fillStyle = sand;
  ctx.fillRect(0, 260, canvas.width, canvas.height - 260);
}

function drawSandTexture() {
  ctx.strokeStyle = "rgba(255,255,255,0.12)";
  ctx.lineWidth = 1;
  for (let y = 300; y < canvas.height; y += 22) {
    ctx.beginPath();
    for (let x = 0; x <= canvas.width; x += 24) {
      const wiggle = Math.sin((x + y) * 0.03) * 3 + Math.cos((x - y) * 0.04) * 2;
      ctx.lineTo(x, y + wiggle);
    }
    ctx.stroke();
  }
}

function drawCourtLines() {
  ctx.save();
  ctx.strokeStyle = "rgba(255, 255, 255, 0.72)";
  ctx.lineWidth = 2;
  ctx.shadowColor = "rgba(0,0,0,0.25)";
  ctx.shadowBlur = 4;
  ctx.strokeRect(40, 300, 380, 160);
  ctx.strokeRect(480, 300, 380, 160);
  ctx.setLineDash([7, 7]);
  ctx.beginPath();
  ctx.moveTo(450, 300);
  ctx.lineTo(450, 460);
  ctx.stroke();
  ctx.restore();
}

function drawVignette(map) {
  const vignette = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 140, canvas.width / 2, canvas.height / 2, 540);
  vignette.addColorStop(0.55, "rgba(0,0,0,0)");
  vignette.addColorStop(1, `rgba(0,0,0,${map.vignetteAlpha})`);
  ctx.fillStyle = vignette;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function drawBackground() {
  const map = maps[settings.mapIndex % maps.length];
  const isIndoor = !!map.indoor;

  drawSky(map);
  drawSun(map, isIndoor);
  drawLightRays(map, isIndoor);
  drawClouds(map, isIndoor);
  drawHorizon(map);
  drawWater(map);
  drawCrowd(map);
  drawSand(map);
  drawSandTexture();
  drawCourtLines();
  
  // Add 3D ground grid when 3D mode is enabled
  if (renderer3D.enabled) {
    draw3DGround();
  }
  
  drawVignette(map);
}

function resetPositions() {
  p1.resetPosition();
  p2.resetPosition();
  botLastJumpFrame = frameCount;
  botSpikeIntent = false;
  // Clear per-bot hit cooldown state at point start
  if (p1) p1._lastHitFrameAny = -999;
  if (p2) p2._lastHitFrameAny = -999;
}
// ================== Bot Logic (Smart Prediction + Tuned Movement + Safer Hits) ==================
let botLastJumpFrame = -100;
let botSpikeIntent = false;

// ==================== Bot AI Helper Functions ====================

/**
 * Get bot difficulty configuration
 * @returns {object} Difficulty config object
 */
function getBotDifficultyConfig() {
  const mode = settings.botDifficulty;
  return CONFIG.BOT_DIFFICULTY[mode] || CONFIG.BOT_DIFFICULTY.normal;
}

function predictBallLandingTime(ball) {
  const y0 = ball.y;
  const vy = ball.vy;
  const g = gravity;

  const a = 0.5 * g;
  const b = vy;
  const c = y0 - groundY;

  const disc = b * b - 4 * a * c;
  if (disc < 0 || Math.abs(a) < 1e-6) {
    return Math.max(8, Math.min(50, (groundY - y0) / Math.abs(vy || 1)));
  }

  const sqrtD = Math.sqrt(disc);
  const t1 = (-b - sqrtD) / (2 * a);
  const t2 = (-b + sqrtD) / (2 * a);

  const tCandidates = [t1, t2].filter(t => t > 0);
  if (!tCandidates.length) return 24;

  const t = Math.min(...tCandidates);
  return Math.max(6, Math.min(55, t));
}

function predictBallLandingX(ball) {
  const t = predictBallLandingTime(ball);
  return ball.x + ball.vx * t;
}

function predictBallSpikeContactX(ball) {
  const baseT = -ball.vy * 0.6 + 12;
  const t = Math.max(7, Math.min(18, baseT));
  return ball.x + ball.vx * t;
}

function calculateBotMoveSpeed(bot, ball, ballOnBotSide, predictedX, diffConfig, deepDefense, netX) {
  const center = bot.x + bot.w / 2;
  const homeX = diffConfig.homeX;
  const baseMoveMultiplier = 1.4 * diffConfig.moveSpeedMultiplier;
  const baseMove = bot.speed * baseMoveMultiplier;
  let moveSpeed = baseMove;

  const targetWhenOnSide = predictedX;
  const targetWhenOffSide = homeX;
  const distToTarget = Math.abs(center - (ballOnBotSide ? targetWhenOnSide : targetWhenOffSide));

  // Distance-based speed adjustments
  const distSpeedFactor = diffConfig.moveSpeedMultiplier;
  if (distToTarget > 140) moveSpeed *= 1.55 * distSpeedFactor;
  else if (distToTarget > 80) moveSpeed *= 1.28 * distSpeedFactor;

  if (deepDefense) {
    moveSpeed *= 1.25 * diffConfig.moveSpeedMultiplier;
  }

  const isIncomingSpike =
    ballOnBotSide &&
    ball.vy > 6 &&
    ball.y < 220 &&
    ball.y > 120;

  const isLikelyFeint =
    ballOnBotSide &&
    Math.abs(ball.vx) < 2.2 &&
    Math.abs(ball.vy) < 4 &&
    ball.y < 260 &&
    ball.y > 160;

  if (isIncomingSpike || isLikelyFeint) moveSpeed *= 1.12 * diffConfig.moveSpeedMultiplier;

  const tapeDefense = ballOnBotSide && ball.y < 260 && ball.vy > 4 && Math.abs(ball.x - netX) < 70;
  if (tapeDefense) {
    moveSpeed *= 1.35 * diffConfig.moveSpeedMultiplier;
  }

  return { moveSpeed, tapeDefense, baseMove };
}

function updateBotMovement(bot, ball, ballOnBotSide, predictedX, targetSpikeX, diffConfig, netX, leftLimit, rightLimit) {
  const center = bot.x + bot.w / 2;
  const homeX = diffConfig.homeX;
  
  const smoothTarget = (current, target, blend = 0.16) => current * (1 - blend) + target * blend;
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  const baseWallBuffer = diffConfig.wallBuffer;
  const defensiveChase = ballOnBotSide && !botSpikeIntent && ball.y > 260 && ball.vy > 0;
  const wallBuffer = defensiveChase ? 28 : baseWallBuffer;

  const deepDefense = ballOnBotSide && (predictedX > 760 || ball.x > 780);
  let { moveSpeed, tapeDefense, baseMove } = calculateBotMoveSpeed(bot, ball, ballOnBotSide, predictedX, diffConfig, deepDefense, netX);

  const rawTarget = ballOnBotSide ? Math.min(predictedX, rightLimit - wallBuffer) : homeX;
  const retreatingDeep = ballOnBotSide && predictedX > center + 80 && !botSpikeIntent;
  const blend = deepDefense ? 0.3 : (retreatingDeep ? 0.28 : 0.2);
  bot._tx = smoothTarget(bot._tx, rawTarget, blend);

  const desiredVel = clamp((bot._tx - center) * 0.08, -moveSpeed, moveSpeed);
  const baseAccel = diffConfig.accelMultiplier;
  let accelLimit = tapeDefense ? (0.55 * baseAccel) : (deepDefense ? (0.45 * baseAccel) : (0.35 * baseAccel));
  if (retreatingDeep) accelLimit += 0.08 * baseAccel;
  if (!ballOnBotSide && ball.vx > 1.8 && ball.y < 360) {
    accelLimit += 0.05 * baseAccel;
    moveSpeed *= 1.04 * diffConfig.moveSpeedMultiplier;
  }
  const accel = clamp(desiredVel - bot._vx, -accelLimit, accelLimit);
  bot._vx = clamp(bot._vx + accel, -moveSpeed, moveSpeed);
  bot.x += bot._vx;

  bot.x = Math.min(Math.max(bot.x, leftLimit), rightLimit);

  if (botSpikeIntent && ballOnBotSide) {
    const aim = targetSpikeX;
    const pull = baseMove * 0.7;
    if (center < aim - 8) bot.x += pull;
    else if (center > aim + 8) bot.x -= pull;
    bot.x = Math.min(Math.max(bot.x, leftLimit), rightLimit);
  }
}

function shouldBotJumpForSpike(bot, ball, ballOnBotSide, targetSpikeX, spikeWallSafe, isServe, diffConfig, grounded, cooldownOver) {
  const center = bot.x + bot.w / 2;
  const inFront = targetSpikeX > bot.x + 6;
  const nearNet = bot.x < 600;
  const closeX = Math.abs(center - targetSpikeX) < diffConfig.spikeProximity;

  const touches = bot.side === "right" ? ball.rightTouches : ball.leftTouches;

  const vyThreshold = 7.2 + (diffConfig.moveSpeedMultiplier * 0.8);
  const wantsToSpike =
    !isServe &&
    ballOnBotSide &&
    grounded &&
    cooldownOver &&
    nearNet &&
    inFront &&
    closeX &&
    spikeWallSafe &&
    ball.y < 360 &&
    ball.y > 90 &&
    ball.vy < vyThreshold &&
    touches >= 1 && touches <= 2;

  return wantsToSpike;
}

function updateBotJumpAndGravity(bot, ball, ballOnBotSide, targetSpikeX, spikeWallSafe, isServe, diffConfig, grounded, cooldownOver) {
  const wantsToSpike = shouldBotJumpForSpike(bot, ball, ballOnBotSide, targetSpikeX, spikeWallSafe, isServe, diffConfig, grounded, cooldownOver);

  if (wantsToSpike) {
    botSpikeIntent = true;
    bot.vy = -bot.jumpPower * 1.1;
    botLastJumpFrame = frameCount;
  }

  bot.vy += gravity;
  bot.y += bot.vy;

  if (bot.y > groundY) {
    bot.y = groundY;
    bot.vy = 0;
    botSpikeIntent = false;
  }
}

function handleBotEmergencyReceives(bot, ball, ballOnBotSide, touches, grounded, netX, homeX) {
  if (
    touches === 0 &&
    ballOnBotSide &&
    Math.abs(ball.x - netX) < 42 &&
    ball.y > 140 &&
    ball.y < 340 &&
    ball.vy < 9
  ) {
    ball.interact(bot, "receive");
    bot._lastHitFrameAny = frameCount;
    return true;
  }

  if (
    ballOnBotSide &&
    Math.abs(ball.x - netX) < 34 &&
    ball.y > 170 &&
    ball.y < 320 &&
    ball.vy > -2.5 &&
    ball.vy < 6
  ) {
    ball.interact(bot, "receive");
    bot._lastHitFrameAny = frameCount;
    bot._tx = homeX;
    return true;
  }

  if (
    ballOnBotSide &&
    touches >= 1 &&
    grounded &&
    ball.vy > 2.2 &&
    ball.y > 300
  ) {
    ball.interact(bot, "receive");
    bot._lastHitFrameAny = frameCount;
    return true;
  }

  return false;
}

function handleBotDefensiveReceive(bot, ball, ballOnBotSide, touches, grounded) {
  const center = bot.x + bot.w / 2;
  
  const withinReach =
    Math.abs(center - ball.x) < 120 &&
    Math.abs(bot.y - ball.y) < 120 &&
    grounded &&
    ball.vy > -0.8 &&
    ball.y > 200;

  if (!botSpikeIntent && touches === 0 && ballOnBotSide) {
    ball.interact(bot, "receive");
    bot._lastHitFrameAny = frameCount;
    return true;
  }

  if (!botSpikeIntent && touches === 1 && ballOnBotSide && withinReach) {
    ball.interact(bot, "set");
    bot._lastHitFrameAny = frameCount;
    return true;
  }

  return false;
}

function handleBotCommittedSpike(bot, ball, ballOnBotSide, targetSpikeX, spikeWallSafe, diffConfig) {
  const center = bot.x + bot.w / 2;
  const proximityThreshold = 205 * (1 + (diffConfig.moveSpeedMultiplier - 1) * 0.5);
  const vyThreshold = 6.4 + (diffConfig.moveSpeedMultiplier * 1.2);
  
  if (
    botSpikeIntent &&
    ballOnBotSide &&
    Math.abs(center - targetSpikeX) < proximityThreshold &&
    ball.y > 112 &&
    ball.y < 332 &&
    ball.vy <= vyThreshold &&
    spikeWallSafe
  ) {
    const nearNetBall = Math.abs(ball.x - 450) < 30;
    if (nearNetBall) {
      ball.vy -= 0.6;
      ball.vx *= 0.94;
    }
    ball.interact(bot, "spike");
    bot._lastHitFrameAny = frameCount;
    return true;
  }

  return false;
}

function handleBotTouchSequence(bot, ball, ballOnBotSide, targetSpikeX, spikeWallSafe, touches, diffConfig, homeX) {
  const center = bot.x + bot.w / 2;

  if (touches === 0) {
    ball.interact(bot, "receive");
    bot._lastHitFrameAny = frameCount;
    return true;
  }

  if (touches === 1) {
    ball.interact(bot, "set");
    bot._lastHitFrameAny = frameCount;
    return true;
  }

  if (touches === 2) {
    const proximityThreshold = 220 * (1 + (diffConfig.moveSpeedMultiplier - 1) * 0.5);
    const vyThreshold = 8.0 + (diffConfig.moveSpeedMultiplier);
    
    if (
      ballOnBotSide &&
      Math.abs(center - targetSpikeX) < proximityThreshold &&
      ball.y > 105 &&
      ball.y < 340 &&
      ball.vy <= vyThreshold &&
      spikeWallSafe
    ) {
      ball.interact(bot, "spike");
    } else {
      ball.interact(bot, "receive");
      const sendDir = bot.side === "right" ? -1 : 1;
      ball.vx = sendDir * 6.5;
      ball.vy = -7.5;
      bot._tx = homeX;
    }
    bot._lastHitFrameAny = frameCount;
    return true;
  }

  return false;
}

// ==================== Main Bot Logic Function ====================

function botLogic(bot) {
  const netX = 450;
  const leftLimit  = 455;
  const rightLimit = canvas.width - bot.w;
  const center = bot.x + bot.w / 2;
  const isServe = (ball.lastTouchedSide === null);
  
  // Get difficulty configuration
  const diffConfig = getBotDifficultyConfig();

  const grounded = bot.y >= groundY - 0.1;
  const cooldownOver = frameCount - botLastJumpFrame > diffConfig.jumpCooldown;

  const homeX = diffConfig.homeX;
  const ballOnBotSide = ball.x > netX;

  if (bot._vx === undefined) bot._vx = 0;
  if (bot._tx === undefined) bot._tx = center;

  const spikeX = predictBallSpikeContactX(ball);
  let predictedX = predictBallLandingX(ball);
  
  const baseWallBuffer = diffConfig.wallBuffer;
  const defensiveChase = ballOnBotSide && !botSpikeIntent && ball.y > 260 && ball.vy > 0;
  const wallBuffer = defensiveChase ? 28 : baseWallBuffer;
  predictedX = Math.min(Math.max(predictedX, leftLimit + 10), rightLimit - wallBuffer);

  const safeSpikeX = Math.min(spikeX, rightLimit - 70 - 12);
  // Hard mode uses safer spike position, easy uses more aggressive
  const targetSpikeX = diffConfig.moveSpeedMultiplier > 1.0 ? safeSpikeX : spikeX;
  const baseSpikeWallMargin = 22 * diffConfig.accelMultiplier;
  const spikeWallBoost = (ball.y < 220 || ball.vy < 3.2) ? (36 / diffConfig.accelMultiplier) : 0;
  const spikeWallSafe = targetSpikeX < rightLimit - (baseSpikeWallMargin + spikeWallBoost);

  updateBotMovement(bot, ball, ballOnBotSide, predictedX, targetSpikeX, diffConfig, netX, leftLimit, rightLimit);
  updateBotJumpAndGravity(bot, ball, ballOnBotSide, targetSpikeX, spikeWallSafe, isServe, diffConfig, grounded, cooldownOver);

  const lastBotHit = bot._lastHitFrameAny || -999;
  const recentSelfSet = ball.lastTouchedSide === bot.side && ball.lastTouchType === "set";
  const minHitCooldown = recentSelfSet ? 6 : 3;
  if (frameCount - lastBotHit < minHitCooldown) return;

  const touches = bot.side === "right" ? ball.rightTouches : ball.leftTouches;
  if (touches >= 3) return;

  if (handleBotEmergencyReceives(bot, ball, ballOnBotSide, touches, grounded, netX, homeX)) return;

  const inFront = targetSpikeX > bot.x + 6;
  const swingForgiveness = (botSpikeIntent && !grounded) ? 28 : diffConfig.swingForgiveness;
  const earlyForgiveness = touches <= 1 ? (36 * diffConfig.reactionMultiplier) : 0;
  const closeEnoughForgiven = Math.abs(center - targetSpikeX) < (138 + swingForgiveness + earlyForgiveness);

  if (handleBotDefensiveReceive(bot, ball, ballOnBotSide, touches, grounded)) return;

  if (!inFront || !closeEnoughForgiven) return;

  if (isServe) {
    if (ballOnBotSide && ball.y > 230) {
      ball.interact(bot, "receive");
    }
    return;
  }

  if (isServe && ballOnBotSide && touches === 0 && botServeDelayFrames > 0) {
    botServeDelayFrames -= 1;
    return;
  }

  if (handleBotCommittedSpike(bot, ball, ballOnBotSide, targetSpikeX, spikeWallSafe, diffConfig)) return;

  if (botSpikeIntent) return;

  if (handleBotTouchSequence(bot, ball, ballOnBotSide, targetSpikeX, spikeWallSafe, touches, diffConfig, homeX)) return;

  ball.interact(bot, "receive");
  bot._lastHitFrameAny = frameCount;
}



// ================== Game Loop ==================
let gameOver = false;



function drawGameOver() {
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.5)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "white";
  ctx.font = "40px Arial";
  const winner = p1.score > p2.score ? "Player 1 Wins!" : "CPU Wins!";
  ctx.fillText("GAME OVER", 310, 220);
  ctx.font = "28px Arial";
  ctx.fillText(winner, 325, 260);
  ctx.font = "18px Arial";
  ctx.fillText(`First to ${settings.targetScore}`, 360, 292);
  ctx.fillText("Press R to restart", 360, 318);
  ctx.restore();
}

function drawPauseOverlay() {
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.45)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "white";
  ctx.font = "32px Arial";
  ctx.textAlign = "center";
  ctx.fillText("Paused", canvas.width / 2, canvas.height / 2 - 80);

  ctx.font = "16px Arial";
  const lines = [
    `1) SFX volume: ${settings.soundLevel === 0 ? "Muted" : (settings.soundLevel < 1 ? "Medium" : "High")}`,
    `2) Trails: ${settings.fxTrails ? "On" : "Off"}`,
    `3) Particles: ${settings.fxParticles ? "On" : "Off"}`,
    `4) Screen shake: ${settings.screenShake ? "On" : "Off"}`,
    `5) Trail theme: ${settings.trailStyle === "glow" ? "Ice" : "Ember"}`,
    `6) Sound style: ${settings.soundStyle === "bright" ? "Bright" : "Soft"}`,
    `7) Bot: ${settings.botDifficulty}`,
    `8) Play to: ${settings.targetScore}`,
    `9) Map: ${maps[settings.mapIndex % maps.length].name}`
  ];

  let y = canvas.height / 2 - 30;
  for (const line of lines) {
    ctx.fillText(line, canvas.width / 2, y);
    y += 22;
  }

  ctx.fillStyle = "rgba(255,255,255,0.8)";
  ctx.fillText("Press P to resume", canvas.width / 2, y + 8);
  ctx.restore();
}

function restartGame() {
  p1.score = 0;
  p2.score = 0;
  ball.spikeCharge = { left: 0, right: 0 };
  ball.reset();
  resetPositions();
  gameOver = false;
}

document.addEventListener("keydown", e => {
  if (gameOver && (e.key === "r" || e.key === "R")) {
    restartGame();
  }
});

function gameLoop(now) {
  const current = Number.isFinite(now) ? now : performance.now();
  const delta = Math.min(50, current - lastTime);
  lastTime = current;
  accumulator += delta;

  while (accumulator >= STEP && !paused) {
    frameCount++;

    if (!gameOver) {
      // Updates
      p1.update("arrowleft", "arrowright", "arrowup");
      // bot update is inside botLogic
      ball.update();

      // Player 1 controls (Arrow Keys to move):
      // q = spike, e = set, s = receive (ground = high bump, air = softer)
      if (keys["e"]) ball.interact(p1, "set");
      if (keys["q"]) ball.interact(p1, "spike");

      if (keys["s"]) {
        // Auto-receive assist: if the ball enters a close bubble, snap a perfect receive
        const px = p1.x + p1.w / 2;
        const py = p1.y + p1.h / 2;
        const dx = ball.x - px;
        const dy = ball.y - py;
        const closeBubble = Math.abs(dx) < 150 && Math.abs(dy) < 170;

        // Extra ceiling rescue: if the ball is high and descending near player, force a catch
        const ceilingRescue = ball.y < 120 && dy > -30 && dy < 200 && Math.abs(dx) < 160;

        if (closeBubble || ceilingRescue) {
          ball.interact(p1, "receive", 70); // bigger forgiving hitbox for perfect pop
        } else {
          ball.interact(p1, "receive", 25);
        }
      }

      // Dive auto-receive: while diving, always attempt a receive with a generous bubble
      if (p1.diveTimer > 0) {
        ball.interact(p1, "receive", 80);
      }

      botLogic(p2);

      // Game over condition
      if (p1.score >= settings.targetScore || p2.score >= settings.targetScore) {
        gameOver = true;
        // Handle gambling winnings
        if (playerStats.currentBet > 0) {
          collectMatchWinnings(p1.score >= settings.targetScore);
        }
      }
      
      // Update extended systems
      updatePowerUps();
      updateArena();
      updateSimulation();
      updateCaterpillar();
    }

    updateFX();
    accumulator -= STEP;
  }

  if (paused) {
    accumulator = 0; // avoid drift while paused
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBackground();
  drawFX();

  drawNet();
  p1.draw();
  p2.draw();
  ball.draw();
  drawScoreboard();
  drawStaminaBar(p1);
  drawSuperCharge(p1);
  drawSuperCharge(p2);
  drawKeybinds();
  
  // Draw extended game systems
  drawModeSelector();
  drawArenaUI();
  drawSimulation();
  drawCaterpillar();
  
  // Draw overlay UIs (last so they appear on top)
  drawShop();
  drawGambling();
  drawChemistry();

  if (gameOver) {
    drawGameOver();
  } else if (paused) {
    drawPauseOverlay();
  }
  
  // Update GUI elements
  updateGUI();

  requestAnimationFrame(gameLoop);
}

// ================== GUI Button Functions ==================
function toggleShop() {
  showingShop = !showingShop;
  showingGambling = false;
  showingChemistry = false;
}

function toggleCasino() {
  showingGambling = !showingGambling;
  showingShop = false;
  showingChemistry = false;
}

function toggleChemistry() {
  showingChemistry = !showingChemistry;
  showingShop = false;
  showingGambling = false;
}

function toggleCaterpillar() {
  caterpillar.active = !caterpillar.active;
  if (caterpillar.active) {
    caterpillar.x = 100;
    caterpillar.hunger = 50;
  }
  document.getElementById('btn-feed').style.display = caterpillar.active ? 'block' : 'none';
}

function feedCaterpillarBtn() {
  if (caterpillar.active) {
    feedCaterpillar();
  }
}

function switchToArena() {
  switchGameMode("arena");
  showingShop = false;
  showingGambling = false;
  showingChemistry = false;
}

function switchToSim() {
  switchGameMode("simulation");
  showingShop = false;
  showingGambling = false;
  showingChemistry = false;
}

function togglePause() {
  paused = !paused;
  keys = {};
  lastTime = performance.now();
}

function updateGUI() {
  // Update coin display
  document.getElementById('coin-count').textContent = playerStats.coins;
  
  // Update caterpillar feed button visibility
  document.getElementById('btn-feed').style.display = caterpillar.active ? 'block' : 'none';
}

// ================== Simple 3D Renderer ==================
const renderer3D = {
  enabled: true,
  camera: {
    x: 450,
    y: 250,
    z: -500,
    fov: 400
  },
  lightSource: { x: 200, y: -300, z: -200 }
};

// Project 3D point to 2D screen coordinates
function project3D(x, y, z) {
  const cam = renderer3D.camera;
  const scale = cam.fov / (cam.fov + z - cam.z);
  return {
    x: cam.x + (x - cam.x) * scale,
    y: cam.y + (y - cam.y) * scale,
    scale: scale
  };
}

// Calculate simple lighting
function calculateLighting(x, y, z, baseColor) {
  const light = renderer3D.lightSource;
  const dx = light.x - x;
  const dy = light.y - y;
  const dz = light.z - z;
  const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
  const intensity = Math.max(0.3, Math.min(1, 800 / dist));
  return intensity;
}

// Draw a 3D sphere (for ball)
function draw3DSphere(x, y, z, radius, color) {
  if (!renderer3D.enabled) return;
  
  const projected = project3D(x, y, z);
  const projectedRadius = radius * projected.scale;
  const lighting = calculateLighting(x, y, z, color);
  
  ctx.save();
  
  // Main sphere with gradient for 3D effect
  const gradient = ctx.createRadialGradient(
    projected.x - projectedRadius * 0.3,
    projected.y - projectedRadius * 0.3,
    0,
    projected.x,
    projected.y,
    projectedRadius
  );
  
  // Parse color and apply lighting
  gradient.addColorStop(0, `rgba(255,255,255,${0.8 * lighting})`);
  gradient.addColorStop(0.3, color);
  gradient.addColorStop(1, `rgba(0,0,0,${0.5})`);
  
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(projected.x, projected.y, projectedRadius, 0, Math.PI * 2);
  ctx.fill();
  
  // Specular highlight
  ctx.fillStyle = `rgba(255,255,255,${0.6 * lighting})`;
  ctx.beginPath();
  ctx.arc(
    projected.x - projectedRadius * 0.25,
    projected.y - projectedRadius * 0.25,
    projectedRadius * 0.2,
    0, Math.PI * 2
  );
  ctx.fill();
  
  ctx.restore();
}

// Draw a 3D box/cuboid (for players, net, etc.)
function draw3DBox(x, y, z, width, height, depth, color, options = {}) {
  if (!renderer3D.enabled) return;
  
  const lighting = calculateLighting(x + width/2, y + height/2, z);
  
  // Front face
  const frontTL = project3D(x, y, z);
  const frontTR = project3D(x + width, y, z);
  const frontBL = project3D(x, y + height, z);
  const frontBR = project3D(x + width, y + height, z);
  
  // Back face
  const backTL = project3D(x, y, z + depth);
  const backTR = project3D(x + width, y, z + depth);
  const backBL = project3D(x, y + height, z + depth);
  const backBR = project3D(x + width, y + height, z + depth);
  
  ctx.save();
  
  // Draw back face (darker)
  ctx.fillStyle = shadeColor(color, -40);
  ctx.beginPath();
  ctx.moveTo(backTL.x, backTL.y);
  ctx.lineTo(backTR.x, backTR.y);
  ctx.lineTo(backBR.x, backBR.y);
  ctx.lineTo(backBL.x, backBL.y);
  ctx.closePath();
  ctx.fill();
  
  // Draw top face
  ctx.fillStyle = shadeColor(color, 20 * lighting);
  ctx.beginPath();
  ctx.moveTo(frontTL.x, frontTL.y);
  ctx.lineTo(frontTR.x, frontTR.y);
  ctx.lineTo(backTR.x, backTR.y);
  ctx.lineTo(backTL.x, backTL.y);
  ctx.closePath();
  ctx.fill();
  
  // Draw right face
  ctx.fillStyle = shadeColor(color, -20);
  ctx.beginPath();
  ctx.moveTo(frontTR.x, frontTR.y);
  ctx.lineTo(backTR.x, backTR.y);
  ctx.lineTo(backBR.x, backBR.y);
  ctx.lineTo(frontBR.x, frontBR.y);
  ctx.closePath();
  ctx.fill();
  
  // Draw front face (brightest)
  ctx.fillStyle = shadeColor(color, 10 * lighting);
  ctx.beginPath();
  ctx.moveTo(frontTL.x, frontTL.y);
  ctx.lineTo(frontTR.x, frontTR.y);
  ctx.lineTo(frontBR.x, frontBR.y);
  ctx.lineTo(frontBL.x, frontBL.y);
  ctx.closePath();
  ctx.fill();
  
  // Draw left face
  ctx.fillStyle = shadeColor(color, -30);
  ctx.beginPath();
  ctx.moveTo(frontTL.x, frontTL.y);
  ctx.lineTo(backTL.x, backTL.y);
  ctx.lineTo(backBL.x, backBL.y);
  ctx.lineTo(frontBL.x, frontBL.y);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
}

// Draw 3D cylinder (for net poles)
function draw3DCylinder(x, y, z, radius, height, color) {
  if (!renderer3D.enabled) return;
  
  const segments = 8;
  const lighting = calculateLighting(x, y, z);
  
  ctx.save();
  
  // Draw cylinder body
  for (let i = 0; i < segments; i++) {
    const angle1 = (i / segments) * Math.PI * 2;
    const angle2 = ((i + 1) / segments) * Math.PI * 2;
    
    const x1 = x + Math.cos(angle1) * radius;
    const z1 = z + Math.sin(angle1) * radius;
    const x2 = x + Math.cos(angle2) * radius;
    const z2 = z + Math.sin(angle2) * radius;
    
    const p1Top = project3D(x1, y, z1);
    const p2Top = project3D(x2, y, z2);
    const p1Bot = project3D(x1, y + height, z1);
    const p2Bot = project3D(x2, y + height, z2);
    
    // Shade based on angle to light
    const shade = Math.cos(angle1) * 30;
    ctx.fillStyle = shadeColor(color, shade * lighting);
    
    ctx.beginPath();
    ctx.moveTo(p1Top.x, p1Top.y);
    ctx.lineTo(p2Top.x, p2Top.y);
    ctx.lineTo(p2Bot.x, p2Bot.y);
    ctx.lineTo(p1Bot.x, p1Bot.y);
    ctx.closePath();
    ctx.fill();
  }
  
  // Draw top ellipse
  const topCenter = project3D(x, y, z);
  ctx.fillStyle = shadeColor(color, 40 * lighting);
  ctx.beginPath();
  ctx.ellipse(topCenter.x, topCenter.y, radius * topCenter.scale, radius * topCenter.scale * 0.3, 0, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.restore();
}

// Helper to shade colors
function shadeColor(color, percent) {
  // Handle hex colors
  if (color.startsWith('#')) {
    let R = parseInt(color.substring(1, 3), 16);
    let G = parseInt(color.substring(3, 5), 16);
    let B = parseInt(color.substring(5, 7), 16);

    R = Math.min(255, Math.max(0, R + percent));
    G = Math.min(255, Math.max(0, G + percent));
    B = Math.min(255, Math.max(0, B + percent));

    return `rgb(${Math.round(R)},${Math.round(G)},${Math.round(B)})`;
  }
  // Handle rgb colors
  const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
  if (match) {
    let R = Math.min(255, Math.max(0, parseInt(match[1]) + percent));
    let G = Math.min(255, Math.max(0, parseInt(match[2]) + percent));
    let B = Math.min(255, Math.max(0, parseInt(match[3]) + percent));
    return `rgb(${Math.round(R)},${Math.round(G)},${Math.round(B)})`;
  }
  return color;
}

// Draw 3D ground plane
function draw3DGround() {
  if (!renderer3D.enabled) return;
  
  ctx.save();
  
  // Draw grid lines for 3D effect
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 1;
  
  const gridSize = 50;
  const gridDepth = 200;
  
  for (let i = 0; i <= 900; i += gridSize) {
    const front = project3D(i, groundY + 90, 0);
    const back = project3D(i, groundY + 90, gridDepth);
    ctx.beginPath();
    ctx.moveTo(front.x, front.y);
    ctx.lineTo(back.x, back.y);
    ctx.stroke();
  }
  
  for (let z = 0; z <= gridDepth; z += gridSize) {
    const left = project3D(0, groundY + 90, z);
    const right = project3D(900, groundY + 90, z);
    ctx.beginPath();
    ctx.moveTo(left.x, left.y);
    ctx.lineTo(right.x, right.y);
    ctx.stroke();
  }
  
  ctx.restore();
}

// Draw 3D shadow under object
function draw3DShadow(x, y, width, height) {
  if (!renderer3D.enabled) return;
  
  ctx.save();
  const shadowY = groundY + 85;
  const projected = project3D(x + width/2, shadowY, 20);
  
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(projected.x, projected.y, width * projected.scale * 0.8, height * projected.scale * 0.2, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

// 3D Character renderer
function draw3DCharacter(player) {
  if (!renderer3D.enabled) return;
  
  const x = player.x;
  const y = player.y;
  const w = player.w;
  const h = player.h;
  const color = player.color;
  const z = player.side === "left" ? 10 : 30; // Slight depth difference
  
  // Shadow
  draw3DShadow(x, y, w, h);
  
  // Body (3D box)
  draw3DBox(x + 5, y + 25, z, w - 10, h - 35, 15, color);
  
  // Head (3D sphere approximation using box)
  const headSize = 18;
  draw3DBox(x + w/2 - headSize/2, y, z + 2, headSize, headSize, 12, '#FFE4C4');
  
  // Arms
  const armWidth = 6;
  const armLength = 25;
  draw3DBox(x - 2, y + 30, z + 5, armWidth, armLength, 5, color);
  draw3DBox(x + w - armWidth + 2, y + 30, z + 5, armWidth, armLength, 5, color);
  
  // Legs
  const legWidth = 8;
  const legLength = 30;
  draw3DBox(x + 8, y + h - legLength, z + 3, legWidth, legLength, 6, color);
  draw3DBox(x + w - legWidth - 8, y + h - legLength, z + 3, legWidth, legLength, 6, color);
}

// Toggle 3D mode
function toggle3D() {
  renderer3D.enabled = !renderer3D.enabled;
}

function toggle3DBtn() {
  toggle3D();
  const btn = document.getElementById('btn-3d');
  if (renderer3D.enabled) {
    btn.classList.add('active');
    btn.textContent = 'üéÆ 3D: ON';
  } else {
    btn.classList.remove('active');
    btn.textContent = 'üéÆ 3D: OFF';
  }
}

// Initialize 3D button state
document.addEventListener('DOMContentLoaded', function() {
  const btn = document.getElementById('btn-3d');
  if (btn) {
    btn.classList.add('active');
    btn.textContent = 'üéÆ 3D: ON';
  }
});

requestAnimationFrame(gameLoop);
</script>

</body>
</html>
